# 📘 Dynamic Programming (DP)

---

## 🔸 개념 요약

**Dynamic Programming**은 큰 문제를 **작은 문제로 나누고**, **중복되는 부분 문제의 결과를 저장하여** 전체 문제를 효율적으로 푸는 방법이다.

* 핵심 조건:
  * ✅ **Optimal Substructure (최적 부분 구조)**
  * ✅ **Overlapping Subproblems (중복 부분 문제)**

---

## 🔸 동작 방식

| 방식              | 설명                     | 키워드                           |
| --------------- | ---------------------- | ----------------------------- |
| Top-Down        | 재귀 + 메모이제이션            | `dfs + memo`                  |
| Bottom-Up       | 반복문 + 테이블              | `dp[i] = ...`                 |
| 상태 정의(State)    | dp\[i]는 i번째 상태에서의 최적값  | `dp[0] = 0` 초기화 등             |
| 점화식(Recurrence) | 이전 상태로부터 현재 상태를 도출하는 식 | `dp[i] = min(dp[i-1], ...)` 등 |

---

## 🔸 개념 정리

### 📌 메모이제이션(Memoization)

> 한 번 계산한 값을 저장해두고, 나중에 같은 계산이 필요할 때 다시 계산하지 않고 꺼내 쓰는 것

* 재귀 함수에서 **같은 인자를 여러 번 계산**할 때, 성능이 급격히 나빠짐.
* 이를 방지하기 위해, **함수 결과를 배열이나 해시맵에 저장**해두고 재사용함.
* 주로 **Top-Down 방식에서 사용**됨.

```java
// 피보나치 수열 (Top-Down with Memoization)
int[] memo = new int[1001];

int fibo(int n) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];
    return memo[n] = fibo(n - 1) + fibo(n - 2);
}
```

### 📌 Top-Down (상향식 DP, 재귀 + 메모이제이션)

> **큰 문제를 먼저 호출**하고, 그 안에서 **작은 문제로 나눠가며 해결**하는 방식

* 구현 방식: **재귀 호출 (`dfs`) + 메모이제이션 배열**
* 재귀 함수가 **이미 계산된 값이면 배열에서 꺼냄**, 아니라면 계산 후 저장
* **재귀적으로 호출되기 때문에 코드 가독성 좋음**, 하지만 **스택 오버플로우 위험** 있음 (Java 기준 약 10⁴\~10⁵ 깊이에서 터짐)
* **큰 문제부터 풀려고 시도, 필요한 작은 문제는 재귀로 계산하며 결과를 저장하는 방식이다.**

```java
int[] memo = new int[n + 1];

int fibo(int n) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];
    return memo[n] = fibo(n - 1) + fibo(n - 2);
}
```

**장점**

* 구현이 직관적이고 간결함
* 필요한 부분만 계산함 (불필요한 계산 안함)

**단점**

* 재귀 깊이에 제한이 있음 (→ 스택 오버플로우 주의(대충 10000번 이상))
* 함수 호출 오버헤드 있음

---

### 📌 Bottom-Up (하향식 DP, 반복문 방식)

> **작은 문제부터 차례차례 쌓아올리듯 푸는 방식**<br>
> **이전 값을 참조해서 하는 것이다.(dp[i] = do[i-1] + dp[i-2])**

* 구현 방식: **반복문으로 배열을 채움**
* `dp[i] = ...` 형태로 이전 값 참조해서 현재 상태 만듦

```java
int[] dp = new int[n + 1];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

**장점**

* 재귀 깊이 걱정 없음
* 성능이 더 빠름 (호출 스택 없음)

**단점**

* 불필요한 모든 경우의 수 계산할 수 있음
* 코드가 덜 직관적일 수 있음

---

### 📌 상태 정의(State Definition)

> `dp[i]`는 어떤 상태를 의미하는가?

* 문제를 해결하기 위해 각 인덱스에 **의미 있는 값을 부여**해야 함
* ex) `dp[i] = i번째 계단까지 오르는 방법의 수`
* ex) `dp[i][j] = 문자열 A의 i번째, B의 j번째까지의 LCS 길이`

**Tip**: 문제를 보면 **무엇을 저장해야 하는가?부터 정의하자**

---

### 📌 점화식(Recurrence Relation)

> 이전 상태를 바탕으로 **현재 상태를 구하는 규칙**

* 피보나치: `dp[i] = dp[i - 1] + dp[i - 2]`
* 계단 오르기: `dp[i] = dp[i - 1] + dp[i - 2]`
* LCS: `dp[i][j] = dp[i-1][j-1] + 1 or max(dp[i-1][j], dp[i][j-1])`
* 냅색: `dp[w] = max(dp[w], dp[w - weight] + value)`

---

### 📌 냅색 문제 (Knapsack Problem)

> 제한된 용량 내에서 **최대의 가치**를 얻는 조합을 구하는 문제

| 유형                  | 설명                                    |
| ------------------- | ------------------------------------- |
| 0/1 Knapsack        | 각 물건을 **한 번만** 넣을 수 있음                |
| Unbounded Knapsack  | 물건을 **여러 번** 넣을 수 있음                  |
| Fractional Knapsack | 물건을 **나눠서** 넣을 수 있음 → DP ❌, Greedy ✔️ |

```java
// 0/1 냅색
for (int i = 0; i < N; i++) {
    for (int w = W; w >= weights[i]; w--) {
        dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
    }
}
```

**왜 w를 거꾸로 도는가?**

* `dp[w]`를 갱신할 때 `dp[w - weight]`가 **이전 i에 의한 값이어야** 하기 때문
* 순방향이면 같은 i에서 업데이트된 값을 또 참조하게 됨 (즉, 중복 사용되므로 틀림)

---

### 📌 DP와 재귀, 브루트포스, 그리디와의 차이

| 기법    | 특징                   | 예시           |
| ----- | -------------------- | ------------ |
| 브루트포스 | 모든 경우의 수 탐색          | 백트래킹, 순열     |
| 재귀    | 문제를 반복적으로 분할해서 해결    | 하노이탑, DFS    |
| DP    | 중복되는 작은 문제 결과를 저장    | 피보나치, 계단, 냅색 |
| 그리디   | 매 순간 최선 선택, 미래 최적 보장 | 거스름돈, 회의실 배정 |

---

필요하면 `.md` 파일로 따로 정리해서 드릴 수 있어.
다음은 `Greedy.md`로 넘어가도 되고, 특정 유형에 대해 더 파보고 싶으면 말해줘.



## 🔸 자주 나오는 유형
1. 냅색(Knapsack)
2. LCS(Longest Common Subsequence)
3. LIS 
4. 그리드(Grid) DP 
5. 트리(Tree) DP 
6. 비트마스킹(Bitmask) DP

## 📌 1. 냅색(Knapsack Problem)

### ✅ 개요
* 한정된 **무게(W)를 가진 가방**에 **가치(value)가 있는 물건**들을 **최대로 담는 방법**을 찾는 문제
* 각 물건은 **무게(weight)와 가치(value)를** 가지고 있음
* 대표적으로 **0/1 냅색**과 **Fractional 냅색**이 있음

### 📦 0/1 Knapsack

> 각 물건을 **한 번만** 담을 수 있고, **쪼갤 수 없음** <br>
> **보통 무게가 중심(j)이다.**

---

#### 🧠 핵심 아이디어

* **DP**를 사용하여 `i번째 물건까지 고려했을 때, 무게 j에서 얻을 수 있는 최대 가치`를 저장
* 상태 정의: `dp[i][j] = i번째까지의 물건 중 무게 j 이하일 때의 최대 가치`

0/1 Knapsack에서는 보통 **무게(W)가 중심**이다.<br>
→ 우리가 구하려는 건 "무게 제한을 넘지 않으면서 최대 가치"<br>
→ 그러니까 상태를 dp[i][j]에서 j를 무게로 잡는 게 자연스럽다.

---

#### ⛓️ 점화식

```
dp[i][j] = dp[i-1][j]                        // i번째 물건을 안 담을 경우
         = max(dp[i-1][j], dp[i-1][j-w] + v) // i번째 물건을 담을 경우 (단, j >= w)
```

---

#### 💻 Java 예제

1. [0/1 Kanpsack 코드 예제(기본, 공간 최적화)](../code/01Knapsack.java)
2. [bounded knapsack](../code/BoundedKnapsack.java)
3. [unbounded knapsack](../code/UnboundedKnapsack.java)
4. [subset sum](../code/SubsetSum.java)

#### 짧은 코드(기본)
```java
public int knapsack(int N, int W, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];

    for (int i = 1; i <= N; i++) {
        for (int w = 0; w <= W; w++) {
            if (weights[i - 1] > w) {
                dp[i][w] = dp[i - 1][w]; // 못 담음
            } else {
                dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            }
        }
    }

    return dp[N][W]; // 전체 물건과 전체 무게 기준 최대 가치
}
```

---

#### 짧은 코드(공간 최적화)

```java
public int knapsack(int N, int W, int[] weights, int[] values) {
    int[] dp = new int[W + 1];

    for (int i = 0; i < N; i++) {
        for (int w = W; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }

    return dp[W];
}
```

---

#### ⏱ 시간복잡도

* 일반 DP: `O(N * W)`
* 공간 최적화 DP: `O(W)`

*** N은 물건의 개수 (items)<br>
*** W는 가방의 최대 무게 (capacity)

---

### 🍰 Fractional Knapsack (분할 가능 냅색)

> 이 유형은 **탐욕법(Greedy)으로 해결**하며, DP와는 별도로 다룸

* 물건을 **쪼갤 수 있음**
* 단위 무게당 가치가 높은 물건부터 담는 방식
* [📎 Fractional Knapsack 자세한 정리는 Greedy 파트에서 보기](그리디.md)

---

### 🔁 0/1 vs Fractional 비교

| 유형                  | 물건 쪼개기 | 해결법    | 시간복잡도      | 특징       |
| ------------------- | ------ | ------ | ---------- | -------- |
| 0/1 Knapsack        | ❌ 불가   | DP     | O(N×W)     | 전형적인 DP  |
| Fractional Knapsack | ✅ 가능   | Greedy | O(N log N) | 가성비 순 정렬 |

### 변형 유형
| 유형                  | 설명                               |
| ------------------- | -------------------------------- |
| **0/1 Knapsack**    | 각 아이템을 0번 또는 1번만 선택 가능           |
| **Unbounded Knapsack** | 아이템을 무한히 사용 가능 → `for w = 0 → K` |
| **Bounded Knapsack** | 아이템별로 사용 가능한 최대 개수 있음            |
| **Subset Sum**      | 가치가 무의미하고, 합이 정확히 가능한지 여부 확인     |
| **Partition Problem** | 배열을 두 그룹으로 나눠 차이를 최소화하는 문제       |
| **배낭 속 최소 아이템 문제**  | 특정 가치를 얻기 위한 최소 무게/최소 개수 찾기 등    |

### 자주 나오는 포인트
- 무게 기준으로 DP를 짜는지, 가치 기준으로 DP를 짜는지 확인
- dp[K] 의미 정확히 파악
- w를 **내림차순(역순)으로** 순회해야 0/1 조건이 유지됨
- 무한히 쓸 수 있으면 w를 오름차순으로 순회

---

물론, 다음은 \*\*LCS (Longest Common Subsequence, 최장 공통 부분 수열)\*\*에 대한 마크다운 정리야:

---

## 📌 2. LCS (Longest Common Subsequence)

### ✅ 개요

* 두 문자열의 **순서를 유지하면서 일부 문자를 삭제해 만들 수 있는 공통 부분 수열** 중 **가장 긴 것의 길이**를 구하는 문제
* **부분 문자열(substring)과는** 다름: 연속일 필요는 없음

> 예시:
> A = `"ACDBE"`
> B = `"ABCDE"`
> LCS = `"ACDE"` → 길이 4

[상세 설명](LCS.md)

---

### 🧠 핵심 아이디어

* **DP를 사용하여 해결**
* `dp[i][j] = 문자열 A의 i번째 문자까지, 문자열 B의 j번째 문자까지 고려했을 때의 LCS 길이`

---

### ⛓️ 점화식

```
if (A[i - 1] == B[j - 1])
    dp[i][j] = dp[i - 1][j - 1] + 1;
else
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
```

---

### 💻 Java 예제(짧은 코드)

```java
public int lcs(String A, String B) {
    int n = A.length();
    int m = B.length();
    int[][] dp = new int[n + 1][m + 1];

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (A.charAt(i - 1) == B.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1; // 같은 문자일 경우
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); // 한쪽 줄이기
            }
        }
    }

    return dp[n][m]; // 전체 문자열 기준 최장 공통 부분 수열 길이
}
```
[전체 코드](../code/LCS.java)

---

### 🔁 LCS vs LIS vs LCSubstring

| 유형          | 설명                         | 연속성 |
| ----------- | -------------------------- | --- |
| LCS         | 두 문자열의 순서를 유지하며 가장 긴 공통 수열 | ❌   |
| LIS         | 한 문자열 내에서 증가하는 가장 긴 부분 수열  | ❌   |
| LCSubstring | 두 문자열의 연속된 공통 부분 문자열       | ✅   |

---

### ⏱ 시간복잡도

* 시간: `O(N × M)`
* 공간: `O(N × M)` (또는 1D 배열로 `O(M)`까지 최적화 가능)

** N, M은 각각의 문자열의 길이

---

### 🌟 자주 나오는 응용

| 응용 문제 유형     | 설명                        |
| ------------ | ------------------------- |
| 공통 부분 수열 복원  | LCS 길이뿐 아니라 어떤 수열이었는지도 추적 |
| 문자열 비교 최소 편집 | Edit Distance에서 응용        |
| 두 수열 유사도 판별  | 바이오인포메틱스, 파일 차이 비교 등에 활용  |

---

### 🔍 주의할 점

* **인덱스 오프셋** 주의 (`dp[i][j]`는 A\[i-1], B\[j-1]를 비교)
* 두 문자열의 길이가 각각 N, M일 때 `dp[N][M]`이 답
* 공백 문자열에 대한 고려 (초기값 0 설정)

---

## 📌 3. LIS (Longest Increasing Subsequence)

### ✅ 개요

* 하나의 수열에서 **일부 원소를 골라서 만든 부분 수열 중, 오름차순으로 정렬된 부분 수열** 중 **가장 긴 것의 길이**를 구하는 문제
* **원소는 연속될 필요 없음 (부분 수열)**

> 예시:
> 수열: `[10, 20, 10, 30, 20, 50]`
> LIS: `[10, 20, 30, 50]` → 길이 = 4

---

### 🧠 핵심 아이디어

#### ① **DP 기반 (O(N²))**

* **원소(배열)의 실제 값을 구할 수 있음**
* 상태 정의:
  `dp[i] = i번째 수를 마지막으로 하는 LIS의 최대 길이`

* 점화식:
  `dp[i] = max(dp[j] + 1)`, 단 `j < i`이고 `arr[j] < arr[i]`

* 초기값: 모든 `dp[i] = 1`로 시작 (각 수는 최소 자기 자신 하나로 LIS를 만들 수 있음)

#### ② **이진 탐색 기반 (O(N log N))**

* 실제 LIS를 구성하진 않지만, **길이만** 빠르게 구할 수 있음
* **그리디 + 이진 탐색**
* `LIS 배열`을 따로 만들어서 유지함
  → 각 원소가 들어갈 **자리(인덱스)를 이진 탐색으로 찾음**

---

### 💻 Java 코드 예제

#### ① DP 방식 (O(N²))

```java
public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);

    int max = 1;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        max = Math.max(max, dp[i]);
    }

    return max;
}
```

#### ② 이진 탐색 방식 (O(N log N))

```java
public int lengthOfLIS(int[] nums) {
    List<Integer> lis = new ArrayList<>();

    for (int num : nums) {
        int idx = Collections.binarySearch(lis, num);

        if (idx < 0) {
            idx = -idx - 1;
        }

        if (idx == lis.size()) {
            lis.add(num);
        } else {
            lis.set(idx, num);
        }
    }

    return lis.size();
}
```
[상세 코드](../code/LIS.java)

---

### 🔁 LCS vs LIS vs LCSubstring 요약

| 유형              | 설명                     | 연속성 | 입력 개수 |
| --------------- | ---------------------- | --- | ----- |
| **LIS**         | 한 수열에서 증가하는 부분 수열      | ❌   | 1개    |
| **LCS**         | 두 수열에서 공통으로 등장하는 부분 수열 | ❌   | 2개    |
| **LCSubstring** | 두 수열에서 연속된 공통 부분 문자열   | ✅   | 2개    |

---

### ⏱ 시간복잡도

| 방법            | 시간복잡도        | 공간복잡도  |
| ------------- | ------------ | ------ |
| DP            | `O(N²)`      | `O(N)` |
| Binary Search | `O(N log N)` | `O(N)` |

---

### 🌟 자주 나오는 응용

| 유형                                       | 설명                               |
| ---------------------------------------- | -------------------------------- |
| **LIS 자체 구하기**                           | DP를 사용해 실제 증가 수열 추적              |
| **LDS (Longest Decreasing Subsequence)** | 내림차순 수열로 바꾸면 동일 방식 적용 가능         |
| **배열 회전 후 LIS**                          | 두 번 이어붙이거나 rotate 후 탐색           |
| **이중 LIS**                               | 앞에서부터 LIS, 뒤에서부터 LIS 각각 구한 뒤 합치기 |

---

### ❗ 주의 포인트

* `이진 탐색 방식`은 LIS 수열 자체를 구할 수 없음 → 오로지 길이만 가능
* 중복 수 허용 여부에 따라 조건 `arr[j] < arr[i]`를 `<=`로 바꾸면 됨
* 수열이 정렬된 상태로 유지되는 건 아님 → 교체하며 유지할 뿐

## 📌 4. 그리드(Grid) DP

> 2차원 격자(보통 `N x M` 배열)에서 위, 아래, 왼쪽, 오른쪽 또는 대각선 등으로 이동하면서 **최적 경로**를 구하는 문제에 사용하는 DP 기법

---

### 전형적인 문제 유형

| 유형      | 설명                       | 예시                                                             |
| ------- | ------------------------ | -------------------------------------------------------------- |
| 최소 경로 합 | 왼쪽 위 → 오른쪽 아래로 이동하며 합 최소 | [LeetCode 64](https://leetcode.com/problems/minimum-path-sum/) |
| 최대 경로 합 | 점프나 제한 조건이 있는 경우         | 백준 1932 (정수 삼각형)                                               |
| 경로 개수   | 갈 수 있는 경로의 수             | 백준 11403, LeetCode 62                                          |
| 조건 제한   | 장애물 피하기, 한 번만 이동 가능 등    | 백준 1520 (내리막 길)                                                |

---

### 예시 코드
1. [최소 경로 합(기본 DP)](../code/GirdDP_MinPathSum.java)
2. [공간 최적화(1차원 배열)](../code/GridDP_1D.java)
3. [DFS + 메모이제이션](../code/GridDP_DFSMemo.java)
4. [경로 수 저장](../code/GridDP_PathCount.java)
5. [점프/이동 제한](../code/GridDP_PathWithObstacles.java)

---

## 📌 5. 자주 등장하는 응용

* 경로 역추적 (LCS처럼)
* 경로 수 저장 (ex. `dp[i][j] = dp[i-1][j] + dp[i][j-1]`)
* 점프/이동 제한 (`k칸 이상 이동`, `장애물` 등)
* DFS + 메모이제이션으로도 변형 가능

좋아. 이제 \*\*트리 DP(Tree Dynamic Programming)\*\*에 대해서 아주 자세히, 예시와 함께 설명해볼게. 처음 보는 사람도 이해할 수 있도록 Markdown 스타일로 정리했어.

---

## 5. 트리 DP (Tree Dynamic Programming)

### 📌 정의

> **트리 DP**는 **트리 구조(계층 구조)** 위에서 동적 계획법(DP)을 적용하는 기법이다.

* 일반적인 1차원/2차원 배열 기반 DP와 다르게, 트리 구조(노드와 간선)에서의 관계를 활용
* 보통 **자식 → 부모 방향 (Bottom-Up)으로 계산**
* 때로는 **부모 → 자식 방향 (Top-Down)도 사용**

---

### 📁 전형적인 예시

#### ✔️ 문제 예시 1: **트리에서 선택한 노드들의 합의 최대값 구하기 (인접 노드 중복 선택 불가)**

> N개의 노드가 있는 트리가 있다. 각 노드에는 정수가 하나씩 적혀 있다.
> **인접한 두 노드를 동시에 선택할 수 없을 때**, 선택한 노드들의 값의 **최댓값**을 구하라.

이건 대표적인 트리 DP 문제다.

---

### 🧠 핵심 아이디어

* 트리는 사이클이 없는 연결 그래프이다. DFS를 돌리기에 적합한 구조!
* 각 노드에서 두 가지 경우를 생각한다:

  1. **해당 노드를 선택한 경우**
  2. **해당 노드를 선택하지 않은 경우**

---

### 📦 DP 테이블 설계

```java
dp[node][0] = node를 선택하지 않은 경우 최대값  
dp[node][1] = node를 선택한 경우 최대값
```

* 이 값을 **DFS 순회하면서 자식 → 부모로 계산**함

---

### 📄 예시 트리와 값

```
     1
    / \
   2   3
  / \
 4   5

각 노드의 값:
1: 10, 2: 1, 3: 5, 4: 4, 5: 3
```

---

### 📘 예시 코드 (Java)

[상세 코드](../code/TreeDP.java)

---

### 📈 시간 복잡도

* `O(N)`
  각 노드를 한 번씩 방문하면서 자식 노드들의 값을 이용해 부모 값을 계산하기 때문

---

### 🧩 트리 DP 문제에서 자주 하는 실수

| 실수          | 설명                                 |
| ----------- | ---------------------------------- |
| ❌ 루트 안 정함   | 트리는 루트를 정해야 DP 설계가 가능              |
| ❌ 방문 체크 안함  | 양방향 그래프라 DFS시 무한 루프 발생 가능          |
| ❌ 메모리 크기 부족 | dp\[node]\[2] 테이블이 필요한데 1차원만 쓰면 오류 |

---

### 🧠 확장 가능한 유형들

* 각 노드에 대한 조건부 최댓값/최솟값
* 노드 간 거리 계산
* 루트가 아닌 특정 노드부터의 DP
* Top-Down 방식으로 DP 전개

---

## 6. 비트마스킹 DP (Bitmask Dynamic Programming)

### 📌 개요

비트마스킹 DP는 **부분 집합 상태**를 표현할 때 `정수의 이진 표현`을 이용하는 방식의 동적 계획법이다.
특히 **상태 수가 너무 많아 배열로 다 담을 수 없을 때**, 각 상태를 `비트`로 표현해서 최적화한다.

**주로 외판원 문제(TSP)를 풀 때 쓰인다.**

---

### 🔧 언제 쓰나?

* **모든 원소의 조합을 고려해야 하는 경우**
  (예: 방문 순서, 조합, 할당 등)
* `N <= 20` 정도일 때 유용
  → 비트마스크 상태 수: `2^N`

---

### 📌 핵심 개념

* 각 상태는 비트를 통해 표현함 (예: 4개 도시 → `0000 ~ 1111`)
* 비트가 `1`이면 해당 요소를 **선택/방문함**, `0`이면 **선택 안 함**
* `dp[bitmask][now] = 최소 비용` 같은 형태로 사용

---

### 주요 문제 : 외판원 순회(TSP)

#### 문제 설명

* 도시 `N`개 (N ≤ 16)
* 모든 도시를 **한 번씩만 방문**하고 원래 도시로 돌아오는 **최소 비용**을 구하라
* 비용은 `W[i][j]` (i → j)

---

#### 🧠 상태 정의

```
dp[visited][current] = visited 상태에서 current 도시에 있을 때의 최소 비용
```

* `visited` → 방문한 도시들의 집합 (비트마스크)
* `current` → 현재 위치한 도시

---

#### 🔁 점화식

```java
for (int next = 0; next < N; next++) {
    if ((visited & (1 << next)) == 0 && W[current][next] != 0) {
        // next 도시를 방문하지 않았고, 길이 있다면
        dp[visited | (1 << next)][next] = 
            min(dp[visited | (1 << next)][next],
                dp[visited][current] + W[current][next]);
    }
}
```

---

### 💻 코드 예시 (Java, N ≤ 16 기준)

[외판원 코드 예시](../code/BitmaskingTSP.java)

---

#### 🔍 시간복잡도 분석

* 상태 수: `2^N * N` → 최대 `2^16 * 16 ≒ 1,048,576`
* 따라서 `N ≤ 16` 이하일 때만 사용 가능
* 이보다 크면 `메모리`, `시간` 모두 터짐

---

### 🧠 팁: 비트 연산 유용 공식

| 의미         | 코드                      |
| ---------- |-------------------------|
| i 번째 비트 켜기 | `mask \| (1 << i)` |
| i 번째 비트 끄기 | `mask & ~(1 << i)`      |
| i 번째 비트 토글 | `mask ^ (1 << i)`       |
| i 번째 비트 체크 | `(mask & (1 << i)) > 0` |
| 전체 상태 초기화  | `1 << N` → 총 `2^N`개     |

---

### 📌 자주 나오는 문제 유형

| 유형           | 설명                     |
| ------------ | ---------------------- |
| 외판원 순회 (TSP) | 도시 방문 조합 최적화           |
| 최소 인원으로 팀 구성 | 부분 집합으로 구성             |
| 최소 비용 할당 문제  | 사람-일 매칭 (e.g. N\*N 매칭) |
| 비트마스킹 + 백트래킹 | 중복 방지 조합 처리            |

---

## 🔸 자주 쓰는 DP 패턴

| 패턴                                                      | 설명        | 예시             |
| ------------------------------------------------------- | --------- | -------------- |
| `dp[i] = dp[i-1] + dp[i-2]`                             | 피보나치 / 계단 | 피보나치, 계단 오르기   |
| `dp[i] = min/max(dp[...]) + cost`                       | 최단/최소 경로  | 삼각형 경로, 정수 삼각형 |
| `dp[i][j] = dp[i-1][j-1] or dp[i][j-1]`                 | 문자열 처리    | LCS, 편집 거리     |
| `dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value)` | 냅색        | 배낭 문제          |

---

## 🔸 실습 추천 문제

---

## 🔸 실수/주의할 점

* ❗ **초기값 설정 실수** → 대부분의 DP 문제는 `dp[0]`, `dp[1]` 값을 어떻게 초기화하느냐가 중요함
* ❗ **배열 크기 설정** → 인덱스 에러 주의 (1-based와 0-based 섞이지 않도록)
* ❗ **탑다운 시 재귀 깊이 초과** → Java에서는 `StackOverflowError` 방지 위해 `@Memo` + 반복식 고려
* ❗ **DP와 그리디 구분**
    * 지금 선택이 미래에 영향 줄 수 있으면 → **DP**
    * 지금 선택이 최적이면서 미래도 최적 보장 → **그리디**

---

## 🔸 기타 고급 패턴

* ✅ **비트 마스크 DP**
* ✅ **트리 DP**
* ✅ **배낭 DP 최적화 (1차원화)**
* ✅ **DP + 이분 탐색 (LIS O(n log n))**
* ✅ **DP + 슬라이딩 윈도우**
* ✅ **DP + 누적합**


