# LCS 설명(상세)

# 1. 기본 구조

---

## 🧪 예제

* 문자열 A = `"ACDBE"`
* 문자열 B = `"ABCDE"`

---

## 목표

* A와 B의 **공통 부분 수열 중 가장 긴 것의 길이**를 구하고자 한다.
* 공통 **부분 수열**이니까, 문자가 반드시 연속할 필요는 없고 **순서만 유지하면 됨**

---

## 🎯 dp\[i]\[j] 의미

> `dp[i][j]`는 **A의 앞 i글자와 B의 앞 j글자까지 비교했을 때의 최장 공통 부분 수열(LCS)의 길이**

---

## 🔧 준비 단계

|    | "" | A | B | C | D | E |
| -- | -- | - | - | - | - | - |
| "" | 0  | 0 | 0 | 0 | 0 | 0 |
| A  | 0  |   |   |   |   |   |
| C  | 0  |   |   |   |   |   |
| D  | 0  |   |   |   |   |   |
| B  | 0  |   |   |   |   |   |
| E  | 0  |   |   |   |   |   |

---

## 📘 채워보자!

우리는 위 테이블을 아래 방향으로, 그리고 왼쪽에서 오른쪽으로 하나씩 채운다.

### ▶ i = 1 (A의 첫 문자 'A')

* j = 1 (B의 첫 문자 'A')
  → A == A → 공통 문자 발견
  → `dp[1][1] = dp[0][0] + 1 = 0 + 1 = 1`

* j = 2\~5 (B의 나머지 문자)
  → A != B/C/D/E
  → `dp[1][j] = max(dp[0][j], dp[1][j-1]) = 이전 행 or 이전 열 중 큰 값`
  → 즉, 값 유지: 1, 1, 1, 1

|    | "" | A | B | C | D | E |
| -- | -- | - | - | - | - | - |
| "" | 0  | 0 | 0 | 0 | 0 | 0 |
| A  | 0  | 1 | 1 | 1 | 1 | 1 |

---

### ▶ i = 2 (A의 두 번째 문자 'C')

* j = 1 (B의 'A')
  → C != A → `dp[2][1] = max(dp[1][1], dp[2][0]) = max(1, 0) = 1`

* j = 2 (B의 'B')
  → C != B → `dp[2][2] = max(dp[1][2], dp[2][1]) = max(1, 1) = 1`

* j = 3 (B의 'C')
  → C == C → 공통 문자!
  → `dp[2][3] = dp[1][2] + 1 = 1 + 1 = 2`

* j = 4\~5
  → C != D/E → `dp = max(dp[1][j], dp[2][j-1])`

|    | "" | A | B | C | D | E |
| -- | -- | - | - | - | - | - |
| "" | 0  | 0 | 0 | 0 | 0 | 0 |
| A  | 0  | 1 | 1 | 1 | 1 | 1 |
| C  | 0  | 1 | 1 | 2 | 2 | 2 |

---

### ▶ i = 3 ('D')

* j = 1\~3
  → D != A/B/C → `dp = max(top, left)` → 유지값

* j = 4 (D == D)
  → `dp[3][4] = dp[2][3] + 1 = 2 + 1 = 3`

* j = 5
  → D != E → `dp = max(top, left)`

|    | "" | A | B | C | D | E |
| -- | -- | - | - | - | - | - |
| "" | 0  | 0 | 0 | 0 | 0 | 0 |
| A  | 0  | 1 | 1 | 1 | 1 | 1 |
| C  | 0  | 1 | 1 | 2 | 2 | 2 |
| D  | 0  | 1 | 1 | 2 | 3 | 3 |

---

### ▶ i = 4 ('B')

* j = 1 (B != A) → 유지
* j = 2 (B == B) → `dp[4][2] = dp[3][1] + 1 = 1 + 1 = 2`
* j = 3\~5 → 계산하면 됨

|    | "" | A | B | C | D | E |
| -- | -- | - | - | - | - | - |
| "" | 0  | 0 | 0 | 0 | 0 | 0 |
| A  | 0  | 1 | 1 | 1 | 1 | 1 |
| C  | 0  | 1 | 1 | 2 | 2 | 2 |
| D  | 0  | 1 | 1 | 2 | 3 | 3 |
| B  | 0  | 1 | 2 | 2 | 3 | 3 |

---

### ▶ i = 5 ('E')

* j = 5 (E == E) → `dp[5][5] = dp[4][4] + 1 = 3 + 1 = 4`

|    | "" | A | B | C | D | E |
| -- | -- | - | - | - | - | - |
| "" | 0  | 0 | 0 | 0 | 0 | 0 |
| A  | 0  | 1 | 1 | 1 | 1 | 1 |
| C  | 0  | 1 | 1 | 2 | 2 | 2 |
| D  | 0  | 1 | 1 | 2 | 3 | 3 |
| B  | 0  | 1 | 2 | 2 | 3 | 3 |
| E  | 0  | 1 | 2 | 2 | 3 | 4 |

---

## ✅ 최종 결과

* `dp[5][5] = 4`
* 즉, 최장 공통 부분 수열의 길이는 4
* 실제 LCS는 `"ACDE"`

---

## 🔚 요약

* 같으면 대각선(dp\[i-1]\[j-1])에서 +1
* 다르면 위(dp\[i-1]\[j])나 왼쪽(dp\[i]\[j-1]) 중 큰 값 가져와
* 한 문자씩 보면서 `최장 길이`를 계속 확장해가는 방식

## 2. 공간복잡도 최적화 구조

