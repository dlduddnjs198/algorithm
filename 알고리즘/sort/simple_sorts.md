# 버블 정렬 - Bubble Sort

> 📌 한 줄 요약: 인접한 두 값을 반복적으로 비교하여 큰 값을 뒤로 밀어내는 가장 단순한 비교 기반 정렬입니다.

---

## 1. 개념 설명
![bubble_img1.gif](../../images/bubble_img1.gif)
- **정렬 방식**: 비교 기반 (Comparison Sort)
- **패러다임**: 반복문 기반 (Brute-force)
- **안정성**: ✅ 안정 정렬 (Stable) – 같은 값의 기존 순서를 유지
- **내부 정렬 여부**: ✅ 내부 정렬 – 추가 메모리 없음

- **작동 원리**:
    - 배열을 왼쪽부터 오른쪽으로 순회하면서 **인접한 두 원소**를 비교
    - 크기 순서가 잘못되었으면 서로 **스왑**
    - 한 바퀴 돌면 **가장 큰 값이 맨 끝으로 이동**  
      → 마치 "거품이 올라가듯이" 큰 값이 뒤로 밀려나는 모습
    - 다음 회전에서는 마지막 값은 정렬되었으므로 제외하고 반복

- **정렬 구간 구조**:
    - 매 라운드마다 **정렬이 끝나는 인덱스가 하나씩 줄어듦**
    - 필요 시 `swapped` 플래그를 두어 **더 이상 교환이 없으면 종료 (O(n) 가능)**

- **특징 요약**:
    - ✅ 코드 구현이 매우 직관적이어서 학습용으로 좋음
    - ❌ 평균/최악 시간복잡도는 O(n²)로 매우 비효율적
    - ❌ 실전 문제에는 거의 사용되지 않음

---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도    |
|-----------------|-----------|
| 최선            | O(n)      |
| 평균            | O(n²)     |
| 최악            | O(n²)     |
| 공간 복잡도     | O(1)      |
| 안정 정렬 여부   | ✅ Stable |

---

## 3. 작동 예시

```text
입력: [5, 1, 4, 2, 8]

1회전 (i = 0 ~ 3):
→ [1, 5, 4, 2, 8]  // 5 > 1 → swap
→ [1, 4, 5, 2, 8]  // 5 > 4 → swap
→ [1, 4, 2, 5, 8]  // 5 > 2 → swap
→ [1, 4, 2, 5, 8]  // 5 < 8 → 유지

2회전 (i = 0 ~ 2):
→ [1, 4, 2, 5, 8]
→ [1, 2, 4, 5, 8]  // 4 > 2 → swap
→ [1, 2, 4, 5, 8]  // 정렬됨

3회전 (i = 0 ~ 1):
→ [1, 2, 4, 5, 8]  // 모두 정렬

4회전 (i = 0):
→ [1, 2, 4, 5, 8]  // 종료 조건 만족

최종 결과: [1, 2, 4, 5, 8]
````

---

## 4. Java 코드 구현

* [기본 구현](./code/BubbleSort.java)
---

## 5. 언제 사용되는가?

* **입력이 매우 작고 단순한 경우** (예: 10개 이하의 데이터)
* **정렬이 거의 되어 있는 경우**, 최적화하면 O(n)까지 동작 가능
* **학습용 구현**으로 가장 적합하며, 내부 로직을 이해하기 쉬움
* **실전에서는 거의 사용되지 않음**, 하지만 **면접에서 설명 요구는 가능성 있음**

---

## 6. 출제 예시 문제

| 플랫폼      | 문제명                     | 링크                                                                       |
| -------- | ----------------------- | ------------------------------------------------------------------------ |

---

## 📌 핵심 요약

| 항목       | 내용              |
| -------- | --------------- |
| 정렬 방식    | 비교 기반           |
| 평균 시간복잡도 | O(n²)           |
| 안정성      | ✅ Stable        |
| 사용 추천도   | ⭐☆☆☆☆           |
| 실전 사용 여부 | 드묾 (거의 사용하지 않음) |

---
# 선택 정렬 - Selection Sort

> 📌 한 줄 요약: 남은 원소 중 최솟값을 매번 선택해 앞으로 보내는, 구현이 쉬운 단순 비교 기반 정렬입니다.

---

## 1. 개념 설명
![selection_img1.gif](../../images/selection_img1.gif)
- **정렬 방식**: 비교 기반 (Comparison Sort)
- **패러다임**: 선택 기반 반복문 구조 (Selection-based Loop)
- **안정성**: ❌ 불안정 정렬 (Unstable) – 같은 값의 기존 순서가 바뀔 수 있음
- **내부 정렬 여부**: ✅ 내부 정렬 – 추가 메모리 사용 없음

- **작동 원리**:
    - 배열의 **현재 위치(i)**를 기준으로
    - 오른쪽 **나머지 구간에서 최솟값의 위치(j)**를 탐색
    - 최솟값을 찾아내면 현재 위치와 **스왑**
    - 이 과정을 **맨 마지막 원소 전까지 반복**하여 정렬 완료

- **정렬 구간 구조**:
    - 정렬된 영역: `arr[0 ~ i-1]`
    - 탐색 대상: `arr[i ~ n-1]` 중 최소값
    - 매 회전마다 정렬 완료 구간이 **왼쪽부터 오른쪽으로 1칸씩 확장됨**

- **특징 요약**:
    - ✅ 구현이 매우 쉽고 직관적임
    - ❌ 비교는 많이 하지만 교환 횟수는 적음 (최대 n-1번)
    - ❌ 안정 정렬이 아님 (같은 값끼리 순서 바뀔 수 있음)
    - ❌ 시간복잡도가 항상 O(n²)로 고정되어 있어 효율이 매우 낮음
    - ✳️ 실전보다는 학습 목적, 특히 "최솟값 선택" 개념을 설명할 때 사용

---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도    |
|-----------------|-----------|
| 최선            | O(n²)     |
| 평균            | O(n²)     |
| 최악            | O(n²)     |
| 공간 복잡도     | O(1)      |
| 안정 정렬 여부   | ❌ Unstable |

---

## 3. 작동 예시

```text
입력: [5, 1, 4, 2, 8]

1회전 (i = 0):
- 남은 구간: [5, 1, 4, 2, 8]
- 최솟값: 1 (index 1)
- 5 ↔ 1 교환 → [1, 5, 4, 2, 8]

2회전 (i = 1):
- 남은 구간: [5, 4, 2, 8]
- 최솟값: 2 (index 3)
- 5 ↔ 2 교환 → [1, 2, 4, 5, 8]

3회전 (i = 2):
- 남은 구간: [4, 5, 8]
- 최솟값: 4 → 제자리 → 유지

4회전 (i = 3):
- 남은 구간: [5, 8]
- 최솟값: 5 → 제자리 → 유지

최종 결과: [1, 2, 4, 5, 8]
````

---

## 4. Java 코드 구현

* [기본 구현](./code/SelectionSort.java)

---

## 5. 언제 사용되는가?

* **데이터 수가 매우 적고, 단순한 비교/교환만 필요한 경우**
* **교환 횟수를 최소화해야 하는 경우** (최대 n-1회만 교환)
* **구현이 쉬워 학습용으로 적합**
* 실전에서는 거의 사용되지 않으며, **안정성이 없어 객체 정렬에는 부적합**

---

## 6. 출제 예시 문제

| 플랫폼    | 문제명      | 링크                                                                       |
| ------ | -------- | ------------------------------------------------------------------------ |

---

## 📌 핵심 요약

| 항목       | 내용              |
| -------- | --------------- |
| 정렬 방식    | 비교 기반           |
| 평균 시간복잡도 | O(n²)           |
| 안정성      | ❌ Unstable      |
| 사용 추천도   | ⭐☆☆☆☆           |
| 실전 사용 여부 | 드묾 (거의 사용하지 않음) |

좋아, 이번엔 \*\*삽입 정렬 (Insertion Sort)\*\*을 동일한 템플릿 형식에 맞춰 정리해줄게.
이건 단순 정렬 중에서는 **실전 응용도 조금 있는 정렬**이라 실제 사용 시점도 함께 담아줬어.

---

# 삽입 정렬 - Insertion Sort

> 📌 한 줄 요약: 이미 정렬된 구간에 새 값을 알맞은 위치에 삽입해가며 정렬을 완성하는, 효율적인 기초 정렬 방식입니다.

---

## 1. 개념 설명
![insertion_img1.gif](../../images/insertion_img1.gif)
- **정렬 방식**: 비교 기반 (Comparison Sort)
- **패러다임**: 점진적 확장 + 삽입 기반 (Insert-into-sorted)
- **안정성**: ✅ 안정 정렬 (Stable) – 같은 값의 순서 유지
- **내부 정렬 여부**: ✅ 내부 정렬 – 추가 메모리 없음

- **작동 원리**:
    - 왼쪽부터 오른쪽으로 배열을 순회하며, 현재 위치의 값을 **key**로 선택
    - 왼쪽 구간은 항상 정렬되어 있다고 가정하고
    - key보다 큰 값들을 **오른쪽으로 밀고**, 빈 자리에 key 삽입
    - 이 과정을 반복하면, 정렬된 구간이 **왼쪽에서 오른쪽으로 확장됨**

- **정렬 구간 구조**:
    - 정렬된 구간: `arr[0 ~ i-1]`
    - key = `arr[i]`는 `arr[i-1] ~ arr[0]`까지 역방향으로 비교
    - key가 삽입될 자리를 찾아, 왼쪽 정렬 구간에 삽입

- **특징 요약**:
    - ✅ 구현이 쉽고 직관적
    - ✅ 거의 정렬된 배열에선 매우 빠름 (O(n))
    - ✅ 안정 정렬이 필요한 문제에 적합
    - ❌ 전체적으로 느림 (평균/최악 O(n²))
    - ✳️ 실전에서 직접 쓰이진 않지만, 라이브러리 정렬(Timsort 등)의 구성 요소로 응용됨

---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도    |
|-----------------|-----------|
| 최선            | O(n)      |
| 평균            | O(n²)     |
| 최악            | O(n²)     |
| 공간 복잡도     | O(1)      |
| 안정 정렬 여부   | ✅ Stable |

---

## 3. 작동 예시

```text
입력: [5, 1, 4, 2, 8]

1단계: i = 1, key = 1
- 정렬된 구간: [5]
- 5 > 1 → 5를 한 칸 밀고 1 삽입
→ [1, 5, 4, 2, 8]

2단계: i = 2, key = 4
- 정렬된 구간: [1, 5]
- 5 > 4 → 5 밀고, 1 < 4 → 4 삽입
→ [1, 4, 5, 2, 8]

3단계: i = 3, key = 2
- 정렬된 구간: [1, 4, 5]
- 5 > 2, 4 > 2 → 밀고, 1 < 2 → 2 삽입
→ [1, 2, 4, 5, 8]

4단계: i = 4, key = 8
- 정렬된 구간: [1, 2, 4, 5]
- 8은 모두보다 크므로 그대로 삽입
→ [1, 2, 4, 5, 8]
````

---

## 4. Java 코드 구현

* [기본 구현](./code/InsertionSort.java)
* [셸 정렬]

---

## 5. 언제 사용되는가?

* **이미 거의 정렬된 데이터**에서 매우 빠름 (O(n))
* **입력 크기가 작을 때 가장 효과적**
* **온라인 입력**을 받으며 정렬 상태를 유지할 때 사용
* **Timsort의 구성 요소**로 사용되며, 실전 언어에서도 내부적으로 응용됨

---

## 6. 출제 예시 문제

| 플랫폼    | 문제명      | 링크                                                                       |
| ------ | -------- | ------------------------------------------------------------------------ |

---

## 📌 핵심 요약

| 항목       | 내용                        |
| -------- | ------------------------- |
| 정렬 방식    | 비교 기반                     |
| 평균 시간복잡도 | O(n²)                     |
| 안정성      | ✅ Stable                  |
| 사용 추천도   | ⭐⭐☆☆☆                     |
| 실전 사용 여부 | 제한적 (작은 입력 or 온라인 입력에 적합) |


# 🔁 정렬 알고리즘 비교 요약

| 정렬 알고리즘       | 평균 시간복잡도 | 최악 시간복잡도 | 공간복잡도 | 안정성 | 주요 특징 |
|---------------------|------------------|------------------|-------------|--------|------------|
| **버블 정렬**       | O(n²)            | O(n²)            | O(1)        | ✅     | 구현 쉬움, 비효율적 |
| **선택 정렬**       | O(n²)            | O(n²)            | O(1)        | ❌     | 교환 최소, 비효율적 |
| **삽입 정렬**       | O(n²)            | O(n²)            | O(1)        | ✅     | 거의 정렬된 배열에 적합 |
| **병합 정렬**       | O(n log n)       | O(n log n)       | O(n)        | ✅     | 안정 정렬, 외부 정렬 가능 |
| **퀵 정렬**         | O(n log n)       | O(n²)            | O(log n)    | ❌     | 평균 빠름, 불안정 정렬 |
| **힙 정렬**         | O(n log n)       | O(n log n)       | O(1)        | ❌     | 우선순위 큐 기반 |
| **셸 정렬**         | O(n log n)~O(n²) | O(n²)            | O(1)        | ❌     | 삽입 정렬 개선형 |
| **카운팅 정렬**     | O(n + k)         | O(n + k)         | O(n + k)    | ✅     | 정수 정렬, 값 범위 작을 때 |
| **기수 정렬**       | O(n × 자릿수)    | O(n × 자릿수)    | O(n + k)    | ✅     | 자릿수 기반, 안정 정렬 |
| **버킷 정렬**       | O(n + k)         | O(n²)            | O(n + k)    | ✅     | 균등 분포에 효과적 |
| **Timsort**         | O(n log n)       | O(n log n)       | O(n)        | ✅     | Java/Python 기본 정렬 |
| **Introsort**       | O(n log n)       | O(n log n)       | O(log n)    | ❌     | C++ STL 기본 정렬 |

> ✅ **안정 정렬(Stable Sort)**: 동일한 값의 기존 순서를 유지하는 정렬  
> ❌ **불안정 정렬(Unstable Sort)**: 동일한 값의 기존 순서가 변경될 수 있음