# 병합 정렬 - Merge Sort

> 📌 한 줄 요약: 배열을 절반으로 쪼개고, 정렬된 상태로 병합하는 분할 정복 기반의 안정 정렬입니다.

---

## 1. 개념 설명
![merge_img1.gif](../../images/merge_img1.gif)

- **정렬 방식**: 비교 기반 (Comparison Sort)
- **패러다임**: 분할 정복 (Divide and Conquer)
- **안정성**: ✅ 안정 정렬 (Stable) – 같은 값의 기존 순서를 유지
- **내부 정렬 여부**: ❌ 외부 정렬 – 추가 메모리 필요 (임시 배열 등)

- **작동 원리**:
    - 배열을 **반씩 분할**하여 더 이상 쪼갤 수 없을 때까지 나눈다
    - 분할된 단위가 1개가 되면, 서로 **정렬된 상태로 병합**하면서 정렬 수행
    - 병합 과정에서 **두 정렬된 배열의 앞쪽 값들을 비교하며 작은 순서대로 삽입**
    - 이 과정을 반복하여 정렬된 하나의 배열로 합쳐짐

- **정렬 구간 구조**:
    - 처음엔 모든 구간이 분할되며 작아지고
    - 이후 병합하면서 정렬된 구간이 점점 **큰 단위로 확장**

- **특징 요약**:
    - ✅ 항상 O(n log n)의 시간복잡도 보장
    - ✅ 안정 정렬이 필요한 상황에서 유용
    - ❌ 내부 정렬이 아님 (추가 배열 필요)
    - ❌ 배열이 작을 땐 오히려 느릴 수 있음
    - ✅ 파일 단위 외부 정렬이나 LinkedList 정렬에도 적합
    - ✅ 데이터 크기가 클수록 안정적


---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도    |
|-----------------|-----------|
| 최선            | O(n log n)|
| 평균            | O(n log n)|
| 최악            | O(n log n)|
| 공간 복잡도     | O(n)      |
| 안정 정렬 여부   | ✅ Stable |

---

## 3. 작동 예시

```text
입력: [5, 1, 4, 2, 8]

1단계 - 분할:
[5, 1, 4, 2, 8]
→ [5, 1, 4] + [2, 8]
→ [5, 1] + [4] + [2] + [8]
→ [5] + [1] + [4] + [2] + [8]

2단계 - 병합:
[5] + [1] → [1, 5]
[1, 5] + [4] → [1, 4, 5]
[2] + [8] → [2, 8]
[1, 4, 5] + [2, 8] → [1, 2, 4, 5, 8]

최종 결과: [1, 2, 4, 5, 8]
````

---

## 4. Java 코드 구현

- [기본 구현(Top down)](code/MergeSortTopDown.java)
- [반복문 구현(Bottom up)](code/MergeSortBottomUp.java)
- [Binary Insertion으로 최적화 버전(그닥 중요하진 않음)](code/MergeSortWithInsertion.java)
- [공간 복잡도를 최적화한 버전(그만큼 시간이 더 걸림)](code/MergeSortInPlace.java)

---

## 5. 언제 사용되는가?

* **항상 O(n log n)을 보장**해야 할 때
* **안정 정렬이 반드시 필요한 경우**
* **정렬 대상이 너무 커서 외부 저장소에서 처리해야 할 때**
* **LinkedList 구조 정렬 시** – 병합 정렬은 포인터로 쉽게 구현 가능
* **Timsort의 핵심 구성 요소**로도 사용됨

---

## 6. 출제 예시 문제

| 플랫폼      | 문제명           | 링크                                                   |
| -------- | ------------- | ---------------------------------------------------- |

---

## 📌 핵심 요약

| 항목       | 내용                    |
| -------- | --------------------- |
| 정렬 방식    | 비교 기반                 |
| 평균 시간복잡도 | O(n log n)            |
| 안정성      | ✅ Stable              |
| 사용 추천도   | ⭐⭐⭐⭐☆                 |
| 실전 사용 여부 | 자주 사용 (특히 안정 정렬 요구 시) |

---

좋아, 지금까지 확정된 포맷 그대로
**퀵 정렬 - Quick Sort**를 `.md`로 완전하게 정리해줄게.
이번엔 실전에서 가장 많이 쓰이는 정렬 중 하나지만 **불안정**하고 **최악엔 느릴 수 있는** 정렬이야.

---

# 퀵 정렬 - Quick Sort

> 📌 한 줄 요약: 기준값(Pivot)을 중심으로 작은 값과 큰 값을 분할하며 정렬하는, 빠르지만 불안정한 대표적인 분할 정복 정렬입니다.

---

## 1. 개념 설명
![quick_img1.gif](../../images/quick_img1.gif)

- **정렬 방식**: 비교 기반 (Comparison Sort)
- **패러다임**: 분할 정복 (Divide and Conquer)
- **안정성**: ❌ 불안정 정렬 (Unstable) – 같은 값의 기존 순서가 바뀔 수 있음
- **내부 정렬 여부**: ✅ 내부 정렬 – 추가 메모리 없이 제자리 정렬 가능

- **작동 원리**:
    - 하나의 **기준값(Pivot)**을 선택
    - 배열을 **Pivot보다 작은 값 / 큰 값**으로 분할
    - 분할된 양쪽 배열에 대해 **재귀적으로 퀵 정렬** 수행
    - 이 과정을 반복하면서 전체 배열이 정렬됨

- **정렬 구간 구조**:
    - Pivot을 기준으로 좌/우로 분할 → 정렬된 Pivot은 자리를 고정
    - 각 분할 구간도 다시 Pivot으로 나뉘며 정렬되므로, **전체 구조는 재귀적**

- **특징 요약**:
    - ✅ 평균적으로 매우 빠름 (O(n log n))
    - ✅ 추가 메모리 거의 없음
    - ❌ 최악엔 느림 (O(n²)), 주로 Pivot 선택이 안 좋을 때 발생
    - ❌ 안정 정렬이 아님 (같은 값의 순서 바뀜)
    - ✅ 실전 정렬에서 가장 널리 쓰임 (C/C++의 기본 정렬 등)

---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도         |
|-----------------|----------------|
| 최선            | O(n log n)     |
| 평균            | O(n log n)     |
| 최악            | O(n²)          |
| 공간 복잡도     | O(log n)       |
| 안정 정렬 여부   | ❌ Unstable     |

---

## 3. 작동 예시

```text
입력: [5, 1, 4, 2, 8]
Pivot 선택: 8 (오른쪽 끝)

Step 1: Partition
→ 모든 원소가 8보다 작으므로 그대로 유지됨
→ 마지막에 pivot과 자기 자리를 swap
→ 분할 결과: [5, 1, 4, 2, 8] → Pivot 위치: 4
→ 왼쪽: [5, 1, 4, 2], 오른쪽: []

---

Step 2: 왼쪽 정렬 ([5, 1, 4, 2]), Pivot: 2

→ 비교하며 작거나 같은 값 앞으로 보냄  
→ 결과: [1, 2, 4, 5], Pivot 위치: 1  
→ 왼쪽: [1], 오른쪽: [4, 5]

---

Step 3: 오른쪽 정렬 ([4, 5]), Pivot: 5  
→ 4는 작으므로 앞으로, Pivot 5는 그대로  
→ 결과: [4, 5], Pivot 위치: 3

---

모든 병합 후: [1, 2, 4, 5, 8]
````

---

## 4. Java 코드 구현

- [기본 구현(Lomuto)](code/QuickSortLomuto.java)
- [Hoare 분할 방식 (비교/교환 횟수가 적고 성능 우수)](code/QuickSortHoare.java)
- [랜덤 피벗 선택 (편향 분할 방지, 평균 성능 안정화)](code/QuickSortRandom.java)
- [3-way QuickSort (중복 많은 배열에 특화)](code/QuickSort3Way.java)
- [Hybrid QuickSort (작은 구간은 삽입 정렬로 전환)](code/QuickSortHybrid.java)
- Dual-Pivot QuickSort (Java 7+의 Arrays.sort(), 두 피벗으로 3구간 분할)

---

## 5. 언제 사용되는가?

* **정렬 성능이 매우 중요한 경우**
* **추가 메모리를 거의 쓰지 못하는 경우**
* **데이터가 무작위에 가까울 때** → 평균 성능 O(n log n)
* **실전 라이브러리에서 가장 많이 채택된 정렬**

    * C의 `qsort()`, C++의 `std::sort()` 등

---

## 6. 출제 예시 문제

| 플랫폼      | 문제명         | 링크                                                 |
| -------- | ----------- | -------------------------------------------------- |

---

## 📌 핵심 요약

| 항목       | 내용                    |
| -------- | --------------------- |
| 정렬 방식    | 비교 기반                 |
| 평균 시간복잡도 | O(n log n)            |
| 안정성      | ❌ Unstable            |
| 사용 추천도   | ⭐⭐⭐⭐⭐                 |
| 실전 사용 여부 | 매우 자주 사용됨 (기본 정렬에 채택) |

# 🔁 정렬 알고리즘 비교 요약

| 정렬 알고리즘       | 평균 시간복잡도 | 최악 시간복잡도 | 공간복잡도 | 안정성 | 주요 특징 |
|---------------------|------------------|------------------|-------------|--------|------------|
| **버블 정렬**       | O(n²)            | O(n²)            | O(1)        | ✅     | 구현 쉬움, 비효율적 |
| **선택 정렬**       | O(n²)            | O(n²)            | O(1)        | ❌     | 교환 최소, 비효율적 |
| **삽입 정렬**       | O(n²)            | O(n²)            | O(1)        | ✅     | 거의 정렬된 배열에 적합 |
| **병합 정렬**       | O(n log n)       | O(n log n)       | O(n)        | ✅     | 안정 정렬, 외부 정렬 가능 |
| **퀵 정렬**         | O(n log n)       | O(n²)            | O(log n)    | ❌     | 평균 빠름, 불안정 정렬 |
| **힙 정렬**         | O(n log n)       | O(n log n)       | O(1)        | ❌     | 우선순위 큐 기반 |
| **셸 정렬**         | O(n log n)~O(n²) | O(n²)            | O(1)        | ❌     | 삽입 정렬 개선형 |
| **카운팅 정렬**     | O(n + k)         | O(n + k)         | O(n + k)    | ✅     | 정수 정렬, 값 범위 작을 때 |
| **기수 정렬**       | O(n × 자릿수)    | O(n × 자릿수)    | O(n + k)    | ✅     | 자릿수 기반, 안정 정렬 |
| **버킷 정렬**       | O(n + k)         | O(n²)            | O(n + k)    | ✅     | 균등 분포에 효과적 |
| **Timsort**         | O(n log n)       | O(n log n)       | O(n)        | ✅     | Java/Python 기본 정렬 |
| **Introsort**       | O(n log n)       | O(n log n)       | O(log n)    | ❌     | C++ STL 기본 정렬 |

> ✅ **안정 정렬(Stable Sort)**: 동일한 값의 기존 순서를 유지하는 정렬  
> ❌ **불안정 정렬(Unstable Sort)**: 동일한 값의 기존 순서가 변경될 수 있음

