# 카운팅 정렬 - Counting Sort

> 📌 한 줄 요약: 정수의 "값 자체"를 인덱스로 활용해 도수 분포 기반으로 정렬하는 알고리즘으로, 값의 범위가 작을 때 매우 빠른 성능을 발휘하는 **비교하지 않는 정렬**입니다.

---

## 1. 개념 설명

- **정렬 방식**: 비비교 정렬 (Non-Comparison Sort)
- **패러다임**: 도수 기반 정렬 (Counting Frequency)
- **안정성**: ✅ 안정 정렬 (Stable)
- **내부 정렬 여부**: ❌ 외부 메모리 사용 (count 배열 필요)

---

### 🔹 작동 원리

1. **각 값이 몇 번 등장하는지 세는 count 배열 생성**
2. **count 배열을 누적합으로 변환 → 각 값이 "어디에 들어가야 하는지"를 계산**
3. **원본 배열을 역순으로 순회**하면서 결과 배열에 값을 위치시킴
4. **output 배열을 반환** → 안정 정렬 유지 가능

---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도         |
|-----------------|----------------|
| 최선            | O(n + k)       |
| 평균            | O(n + k)       |
| 최악            | O(n + k)       |
| 공간 복잡도     | O(n + k)       |
| 안정 정렬 여부   | ✅ Stable       |

> ※ `n`: 원소 수 / `k`: 값의 최대 범위 (`max - min + 1`)

---

## 3. 작동 흐름 예시 (핵심 아이디어 포함)

입력 배열: `[4, 2, 2, 8, 3, 3, 1]`  
값의 범위: 0 ~ 8

---

### 🟦 Step 1: 값 개수 세기 (`count[] 배열 생성`)

```text
index:  0  1  2  3  4  5  6  7  8
count:  0  1  2  2  1  0  0  0  1
````

---

### 🟨 Step 2: 누적합으로 위치 계산 (prefix sum)

> 누적합의 의미:
> `count[i]`는 "**값 i가 정렬된 배열에서 끝나는 위치의 직후 인덱스**"를 나타냄

```text
누적합 결과:

index:  0  1  2  3  4  5  6  7  8
count:  0  1  3  5  6  6  6  6  7
```

---

### 🟩 Step 3: output\[] 배열 생성 (역순 정렬 수행 - 안정 정렬)

입력 배열: `[4, 2, 2, 8, 3, 3, 1]` (역순 순회)

```text
1 → count[1] = 1 → output[0] = 1, count[1]--
3 → count[3] = 5 → output[4] = 3, count[3]--
3 → count[3] = 4 → output[3] = 3, count[3]--
8 → count[8] = 7 → output[6] = 8, count[8]--
2 → count[2] = 3 → output[2] = 2, count[2]--
2 → count[2] = 2 → output[1] = 2, count[2]--
4 → count[4] = 6 → output[5] = 4, count[4]--

최종 결과: `[1, 2, 2, 3, 3, 4, 8]`
```

---

### ✅ 핵심 직관 요약

* `count[]`의 누적합은 **정렬 결과에서 각 값이 차지할 위치**를 알려줌
* **역순 순회**로 안정 정렬 구현 가능 (동일한 값의 기존 순서를 유지)
* **값을 인덱스로 직접 사용하는 구조** → 비교 연산 없이 정렬 가능

---

## 4. Java 코드 구현

* [기본 구현 (양의 정수 전용)](./code/CountingSort.java)
* [음수 포함 버전 (범위 일반화)](./code/CountingSortNegative.java)

---

## 5. 언제 사용되는가?

* **정수만 존재**하고 값의 범위가 **좁을 때** (예: 점수, 나이, 순위 등)
* **실수, 문자열, 중복 많은 데이터**에는 부적합
* 값의 빈도를 분석하거나 **히스토그램 정렬, 그룹 정렬**이 필요한 상황에서 효과적

---

## 6. 출제 예시 문제

| 플랫폼      | 문제명                          | 링크                                                                       |
| -------- | ---------------------------- | ------------------------------------------------------------------------ |

---

## 📌 핵심 요약

| 항목       | 내용                        |
| -------- | ------------------------- |
| 정렬 방식    | 비교하지 않는 정수 기반 정렬          |
| 시간복잡도    | O(n + k) (`k`: 값의 범위)     |
| 공간 복잡도   | O(n + k)                  |
| 안정성      | ✅ Stable                  |
| 사용 추천도   | ⭐⭐⭐⭐☆                     |
| 실전 사용 여부 | ✅ 자주 출제됨 (단, 범위 조건 명시될 때) |

---

## 💬 마무리 한 줄 요약

> 카운팅 정렬은 "정렬은 반드시 비교가 필요하다"는 고정관념을 깨뜨리는 대표적인 알고리즘입니다.
> 정수 정렬에서 빠른 성능이 필요한 경우, 어떤 정렬보다도 강력합니다.

---

좋아! 아래는 \*\*기수 정렬(Radix Sort)\*\*에 대한 정리된 `.md` 문서야.
카운팅 정렬과 비슷하지만, **자리수 기준 반복 정렬**이라는 점에서 핵심 개념과 예시 흐름이 더 중요해.
지금까지 사용한 포맷에 맞춰 구성했어:

---

# 기수 정렬 - Radix Sort

> 📌 한 줄 요약: 정수(또는 문자열)의 **각 자리수(LSD 또는 MSD)를** 기준으로 여러 번 정렬하여 전체 순서를 맞추는 **비교하지 않는 정렬 알고리즘**입니다.

---

## 1. 개념 설명

- **정렬 방식**: 비비교 정렬 (Non-Comparison Sort)
- **패러다임**: 자릿수 기반 반복 정렬
- **안정성**: ✅ 안정 정렬 (Counting Sort 기반 사용 시)
- **내부 정렬 여부**: ❌ 외부 정렬 – 각 자릿수 정렬 시 보조 배열 필요

---

### 🔹 작동 원리

1. 자릿수 기준으로 하나씩 분리 (1의 자리 → 10의 자리 → 100의 자리 ...)
2. **각 자릿수별로 안정 정렬** 수행 (보통 Counting Sort 사용)
3. 자릿수가 가장 높은 자리까지 모두 반복 → 전체 정렬 완료

> 보통 **LSD 방식 (가장 낮은 자릿수부터 시작)**이 일반적  
> 문자열일 경우 **MSD 방식**도 사용

---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도             |
|-----------------|--------------------|
| 최선            | O(n × d)           |
| 평균            | O(n × d)           |
| 최악            | O(n × d)           |
| 공간 복잡도     | O(n + k) (자리별 보조 배열) |
| 안정 정렬 여부   | ✅ Stable           |

> ※ `d`: 자릿수의 수 / `k`: 각 자릿수의 최대값 (보통 0~9)

---

## 3. 작동 흐름 예시 (LSD 방식)

입력 배열: `[170, 45, 75, 90, 802, 24, 2, 66]`

### Step 1️⃣: 1의 자리 정렬 (Counting Sort 기반)

```text
→ [170, 90, 802, 2, 24, 45, 75, 66]
(정렬 순서: 0 → 2 → 4 → 5 → 5 → 6 → 0 → 2)
````

### Step 2️⃣: 10의 자리 정렬

```text
→ [802, 2, 24, 45, 66, 170, 75, 90]
(정렬 순서: 0 → 0 → 2 → 4 → 6 → 7 → 7 → 9)
```

### Step 3️⃣: 100의 자리 정렬

```text
→ [2, 24, 45, 66, 75, 90, 170, 802]
(정렬 순서: 0 → 0 → 0 → 0 → 0 → 0 → 1 → 8)
```

---

✅ 최종 정렬 결과: `[2, 24, 45, 66, 75, 90, 170, 802]`

> 항상 **가장 낮은 자리수부터 정렬하는 LSD 방식**을 사용하면,
> 자릿수가 늘어날수록 정렬이 점점 안정화된다.

---

## 4. Java 코드 구현

* [기본 구현 (LSD 정수 기반)](./code/RadixSort.java)

> ☝ Counting Sort를 보조 정렬로 사용하여 안정성을 확보합니다.

---

## 5. 언제 사용되는가?

* **정수 값이 크지만, 자릿수는 제한적인 경우** (ex: 전화번호, 학번, 주민번호 등)
* **문자열 정렬 (고정 길이)에도** 응용 가능 (MSD 방식 활용)
* **정렬 기준이 복잡할 필요 없고, 비교가 비효율적인 경우** 매우 유리

> 단, 자릿수마다 안정 정렬이 수행되어야 하므로 **Counting Sort 기반이 필수**

---

## 6. 출제 예시 문제

| 플랫폼      | 문제명                     | 링크                                                 |
| -------- | ----------------------- | -------------------------------------------------- |

---

## 📌 핵심 요약

| 항목       | 내용                       |
| -------- | ------------------------ |
| 정렬 방식    | 비교하지 않는 정수/문자열 자릿수 정렬    |
| 시간복잡도    | O(n × d) (`d`: 자릿수 개수)   |
| 공간 복잡도   | O(n + k) (Counting 배열 등) |
| 안정성      | ✅ Stable                 |
| 사용 추천도   | ⭐⭐⭐⭐☆                    |
| 실전 사용 여부 | 자주 출제되진 않지만 빠르고 안정적임     |

---

## 💬 마무리 한 줄 요약

> 기수 정렬은 "정수의 자릿수"나 "문자열의 위치"로 정렬해야 할 때 최고의 효율을 보여줍니다.
> 단, 내부적으로 안정 정렬이 필수이므로 Counting Sort와의 결합이 핵심입니다.

---

좋아, 이번에는 \*\*버킷 정렬 (Bucket Sort)\*\*에 대해 지금까지의 스타일에 맞춰 완성도 있게 `.md`로 정리해줄게.
기수 정렬이나 카운팅 정렬과 마찬가지로 비교를 하지 않는 정렬이지만, **값이 균등하게 분포된다는 가정** 아래에서 성능이 극대화되는 알고리즘이야.

---

# 버킷 정렬 - Bucket Sort

> 📌 한 줄 요약: 데이터를 일정 범위별로 나누어 여러 개의 "버킷"에 분산시킨 뒤, 각 버킷을 개별 정렬하여 합치는 방식의 정렬입니다.  
> 실수, 소수, 균등 분포된 값에 매우 강력합니다.

---

## 1. 개념 설명

- **정렬 방식**: 비비교 정렬 (Non-Comparison Sort)
- **패러다임**: 분할 정렬 (Distribution Sort)
- **안정성**: ✅ 구현 방식에 따라 안정 가능 (각 버킷에서 안정 정렬 사용 시)
- **내부 정렬 여부**: ❌ 보조 구조 필요 (리스트, 배열 등)

---

### 🔹 작동 원리

1. 입력 데이터를 일정 구간 단위로 나눌 수 있는 **버킷(bucket) 배열** 생성
2. 각 데이터를 해당하는 구간의 버킷에 삽입
3. 각 버킷 내부를 정렬 (보통 **삽입 정렬 / 병합 정렬 / 퀵 정렬** 사용)
4. 버킷들을 차례대로 이어붙이면 전체 정렬 결과가 완성

> 입력 데이터가 **균등하게 분포**되어 있을수록 각 버킷의 정렬 비용이 작아짐 → 전체 속도가 빨라짐

---

## 2. 시간 및 공간 복잡도

| 구분            | 복잡도             |
|-----------------|--------------------|
| 최선            | O(n + k)           |
| 평균            | O(n + k)           |
| 최악            | O(n²)              |
| 공간 복잡도     | O(n + k)           |
| 안정 정렬 여부   | ✅ (버킷 내 정렬이 안정 정렬일 경우) |

> `k`: 버킷 개수  
> `n`: 전체 데이터 개수

---

## 3. 작동 흐름 예시

입력 배열: `[0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]`

### Step 1️⃣: 값의 범위 [0.0, 1.0) → 버킷 10개 생성

- 각 버킷 구간 = 0.1  
  버킷[0] → [0.0 ~ 0.1)  
  버킷[1] → [0.1 ~ 0.2)  
  ...

### Step 2️⃣: 값 분배

```text
버킷[1] → [0.17, 0.12]  
버킷[2] → [0.21, 0.23, 0.26]  
버킷[3] → [0.39]  
버킷[6] → [0.68]  
버킷[7] → [0.72, 0.78]  
버킷[9] → [0.94]
````

### Step 3️⃣: 각 버킷 정렬 (삽입 정렬 등 사용)

```text
버킷[1] → [0.12, 0.17]  
버킷[2] → [0.21, 0.23, 0.26]  
버킷[7] → [0.72, 0.78]
```

### Step 4️⃣: 모든 버킷을 이어붙이기

```text
최종 정렬 결과: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]
```

---

## 4. Java 코드 구현

* [기본 구현 (실수 분포 기반)](./code/UniformBucketSort.java)

> 보통 각 버킷은 `ArrayList<Double>`로 구현하며, 내부 정렬은 `Collections.sort()` 또는 삽입 정렬로 처리합니다.

---

## 5. 언제 사용되는가?

* 입력이 **\[0, 1)** 사이의 **실수형 데이터**일 때
* 데이터가 **균등하게 분포**되어 있을 때 (ex. 난수 배열, 평균적인 실수 값)
* 실시간으로 **데이터 그룹화 + 정렬**을 동시에 처리할 때

> 주의: 입력값이 **불균등하거나 범위가 너무 넓으면** 오히려 느려질 수 있음

---

## 6. 출제 예시 문제

| 플랫폼      | 문제명                 | 링크                                               |
| -------- | ------------------- | ------------------------------------------------ |
| 없음       | 직접 구현 문제로 간혹 등장     | 실수 정렬 / 버킷 기반 집계 문제 형태로 출제됨                      |

---

## 📌 핵심 요약

| 항목       | 내용                              |
| -------- | ------------------------------- |
| 정렬 방식    | 비비교 정렬 (분포 기반)                  |
| 시간복잡도    | O(n + k) (이론상), 최악 O(n²)        |
| 공간 복잡도   | O(n + k)                        |
| 안정성      | ✅ 가능 (버킷 내부 안정 정렬 시)            |
| 사용 추천도   | ⭐⭐⭐⭐☆                           |
| 실전 사용 여부 | 제한적 (실수 정렬, 값 범위 조건 명시 시 매우 강력) |

---

## 💬 마무리 한 줄 요약

> 버킷 정렬은 데이터를 미리 **그룹핑하고 병렬 정렬**하는 방식으로,
> 값이 **균일하게 분포된 실수** 정렬에 최적화된 정렬 알고리즘입니다.

