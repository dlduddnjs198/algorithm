# ⚙️ 정렬 + 알고리즘 패턴 조합

> 정렬은 그 자체로 쓰이기보다, **다른 알고리즘 기법과 함께 조합되어 문제를 푸는 핵심 도구**입니다.  
> 이 문서는 대표적인 4가지 조합을 중심으로 **원리, 사용 맥락, 흐름, 실전 문제**까지 구체적으로 설명합니다.

---

## 1. 🧲 정렬 + 투 포인터

### 🔍 개념과 원리

- **정렬된 배열**에서 **양쪽 포인터**를 좁혀가며 원하는 조건을 만족하는 쌍을 찾는 방식.
- 정렬을 통해 **크기 관계가 보장되므로**, 두 포인터만으로도 탐색이 가능.
- 시간복잡도는 `O(n)`까지 가능하며, **브루트포스 `O(n²)`보다 훨씬 빠름.**

---

### 🧠 어떤 상황에 쓰이나?

- 합이 특정 값이 되는 **두 수 / 세 수 / 네 수** 찾기
- 두 포인터로 구간 내에서 **최솟값 / 최댓값 / 조건 만족 쌍의 개수** 세기
- 정렬된 배열에서 특정 조건을 만족하는 **범위**를 구할 때

---

### 💡 작동 흐름 예시: "합이 10인 두 수 찾기"

```java
int[] arr = {1, 4, 6, 2, 7, 5, 3}; // 입력 배열
Arrays.sort(arr); // [1, 2, 3, 4, 5, 6, 7]

int left = 0, right = arr.length - 1;
while (left < right) {
    int sum = arr[left] + arr[right];
    if (sum == 10) {
        System.out.println("찾았다: " + arr[left] + " + " + arr[right]);
        left++; right--;
    } else if (sum < 10) left++;
    else right--;
}
````

---

### ✅ 실전 문제 예시

* BOJ 3273: 두 수의 합
* BOJ 2470: 두 용액
* LeetCode: 3Sum, 4Sum

---

## 2. 🎯 정렬 + 이분 탐색 (Binary Search)

### 🔍 개념과 원리

* 정렬된 배열에서 **조건에 맞는 값이나 인덱스**를 \*\*이분 탐색(log N)\*\*으로 빠르게 찾는 기법.
* 탐색 대상은 **값 그 자체**일 수도 있고, **조건을 만족하는 경계값**일 수도 있음.
* 특히 **lower\_bound / upper\_bound** 를 찾을 때 자주 사용됨.

---

### 🧠 어떤 상황에 쓰이나?

* "이 값이 배열에 있는가?" → 정렬 후 이분 탐색
* "이 값 이상인 첫 번째 원소는 어디인가?" → `lower_bound`
* "이 조건을 만족하는 최소/최댓값은 무엇인가?" → **Parametric Search**로 범위 이분탐색

---

### 💡 작동 흐름 예시: lower\_bound 구현

```java
// arr은 정렬되어 있음
int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length;
    while (left < right) {
        int mid = (left + right) / 2;
        if (arr[mid] < target) left = mid + 1;
        else right = mid;
    }
    return left;
}
```

---

### ✅ 실전 문제 예시

* BOJ 1920: 수 찾기
* BOJ 10816: 숫자 카드 2
* BOJ 2110: 공유기 설치 (Parametric Search)

---

## 3. 🧮 정렬 + 누적합 (Prefix Sum)

### 🔍 개념과 원리

* 정렬한 후 누적합을 구하면, 특정 조건을 만족하는 **전체 합, 평균, 대기 시간** 등을 빠르게 계산할 수 있음.
* 특히 정렬 기준에 따라 누적합의 **전체적인 결과가 달라지는** 경우에 필수.

---

### 🧠 어떤 상황에 쓰이나?

* 최소 대기 시간, 최소 처리 시간 등 → 빠른 순으로 처리하는 것이 유리
* 정렬된 상태에서 누적 비용을 계산해야 하는 경우
* 입력값이 정렬된 뒤 **앞에서부터 더해지는 구조**일 때

---

### 💡 작동 흐름 예시: ATM 문제

```text
입력: [3, 1, 4, 3, 2] → 정렬: [1, 2, 3, 3, 4]

각 사람이 기다리는 시간:
1, 1+2, 1+2+3, 1+2+3+3, ...

총합 = 1 + 3 + 6 + 9 + 13 = 32 → 최소 대기 시간
```

---

### ✅ 실전 문제 예시

* BOJ 11399: ATM
* BOJ 11659: 구간 합 구하기

---

## 4. 🧱 정렬 + 좌표 압축 (Coordinate Compression)

### 🔍 개념과 원리

* 입력 값의 범위가 너무 클 경우 (`1 ≤ x ≤ 10⁹`) → 인덱스로 직접 쓰기 힘듦
* 값을 \*\*정렬 후 인덱스로 매핑(압축)\*\*해서 `0 ~ N-1` 사이로 변환
* 이후 `카운팅 배열`, `세그먼트 트리`, `BIT` 등에서 사용 가능

---

### 🧠 어떤 상황에 쓰이나?

* 값의 범위는 크지만, **실제로 등장하는 값의 종류는 적은 경우**
* 값 → 위치 인덱스 변환이 필요한 문제 (ex. 구간 세기, 빈도 저장 등)
* 세그먼트 트리, 펜윅 트리 등에서 index 기반 처리 시

---

### 💡 작동 흐름 예시

```java
int[] arr = {1000, 500, 1000, 2000};

Set<Integer> set = new TreeSet<>();
for (int x : arr) set.add(x); // 정렬 + 중복 제거

Map<Integer, Integer> compress = new HashMap<>();
int idx = 0;
for (int x : set) compress.put(x, idx++);

// 결과: 500→0, 1000→1, 2000→2
```

---

### ✅ 실전 문제 예시

* BOJ 18870: 좌표 압축
* BOJ 2042: 구간 합 구하기 (인덱스를 줄여야 segment tree 사용 가능)

---

## 📌 전체 요약

| 조합 유형      | 핵심 원리                                | 대표 문제 유형                  |
| ---------- | ------------------------------------ | ------------------------- |
| 정렬 + 투 포인터 | 정렬된 배열에서 양쪽 포인터를 이동하며 합/쌍 탐색         | 두 수의 합, 세 수의 합, 두 용액 문제 등 |
| 정렬 + 이분 탐색 | 정렬 후 특정 값이나 조건을 만족하는 경계값을 log N 탐색   | 수 찾기, 경계 탐색, 파라메트릭 서치     |
| 정렬 + 누적합   | 정렬된 순서에서 앞에서부터 누적하여 합/기대값/대기시간 계산    | 최소 대기 시간, 누적 비용 최적화 문제    |
| 정렬 + 좌표 압축 | 값이 큰 경우, 값 → 작은 인덱스로 압축하여 배열/트리에서 사용 | 세그먼트 트리, BIT, 압축 빈도 문제 등  |

---

## 💬 정리 문장

> 정렬은 단순히 배열을 정리하는 게 아니라,
> **투 포인터, 이분 탐색, 누적합, 좌표 압축**처럼
> **다른 알고리즘의 전제조건이 되며 핵심 도구로 사용된다.**
