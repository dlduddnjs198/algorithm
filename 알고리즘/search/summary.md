# 🔍 탐색 알고리즘 분류

## 📌 목차

- [1. 선형 탐색 (Linear Search)](#1-선형-탐색-linear-search)
- [2. 이진 탐색 기반 (Binary Search)](#2-이진-탐색-기반-binary-search)
- [3. 해시 탐색](#3-해시-탐색)
- [4. 문자열 탐색](#4-문자열-탐색)
- [5. 그래프 탐색](#5-그래프-탐색)
- [6. 트리/구간 구조 탐색](#6-트리구간-구조-탐색)
- [🧠 참고 요약](#🧠-참고-요약)

---

## 1. 선형 탐색 (Linear Search)

- 기본 순차 탐색 (for/while)
- 완전 탐색 (Brute Force)
- **[백트래킹](detail/backtracking.md)**
- **[비트마스크](detail/bitmask.md)**
- 순열 탐색
- 조합 탐색
- 부분집합 탐색
    - 재귀
    - 비트마스킹

---

## 2. 이진 탐색 기반 (Binary Search)

- [정렬된 배열 탐색](detail/binarysearch.md)
- [파라메트릭 서치](detail/binarysearch.md)
- [삼진 탐색 (Ternary Search)](detail/binarysearch.md)
- [지수 탐색 (Exponential Search)](detail/binarysearch.md)

---

## 3. 해시 탐색

탐색 성능을 높이기 위해 자주 사용하는 **해시 기반 자료구조**입니다.  
자세한 동작 방식과 내부 구조는 [자료구조 정리](../datastructure/summary.md)를 참고하세요.

### 🔸 HashSet

- **언제 사용하나?**  
  어떤 값이 **이미 등장했는지** 빠르게 확인할 때.  
  예: 배열 중복 제거, 방문 기록 체크, 등장 여부 판별 문제 등.
- **특징**
  - 중복을 허용하지 않음
  - 평균적으로 삽입/탐색 O(1)
  - 저장 순서와 정렬은 보장하지 않음

### 🔸 HashMap

- **언제 사용하나?**  
  특정 **키에 대응하는 값을 저장하거나 찾을 때**.  
  예: 문자열 빈도 세기, 인덱스 기록, 쌍 정보 저장 등.
- **특징**
  - Key-Value 구조 (키 중복 불가)
  - 평균적으로 삽입/탐색/삭제 O(1)
  - 순서와 정렬은 없음

### 🔸 LinkedHashSet

- **언제 사용하나?**  
  **중복 제거**와 동시에 **입력된 순서대로 순회**가 필요할 때.  
  예: 순서 유지가 필요한 중복 제거 문제.
- **특징**
  - HashSet + 입력 순서 보존
  - 삽입/탐색 평균 O(1)
  - 순서 기반 처리에 적합

### 🔸 LinkedHashMap

- **언제 사용하나?**  
  Key-Value 구조에서 **입력 순서 또는 접근 순서 유지**가 필요한 경우.  
  예: LRU Cache 구현, 순차적 키 처리 등.
- **특징**
  - HashMap + 순서 보존 기능
  - `accessOrder=true` 설정 시 최근 접근 순으로 재정렬 가능
  - 삽입/탐색 평균 O(1)

### 🔸 TreeSet

- **언제 사용하나?**  
  값을 정렬된 상태로 유지하면서 **범위 기반 탐색**이 필요한 경우.  
  예: x 이상인 값 중 최소값 찾기, 이분탐색 대체 등.
- **특징**
  - 내부적으로 Red-Black Tree 사용
  - 자동 오름차순 정렬
  - 삽입/탐색/삭제 O(log n)
  - `floor`, `ceiling`, `higher`, `lower` 등 제공

### 🔸 TreeMap

- **언제 사용하나?**  
  키를 정렬된 상태로 유지하면서, **범위 조건 탐색**이나 **구간 쿼리**가 필요할 때.  
  예: 특정 구간 내 최솟값, 최댓값 찾기 등.
- **특징**
  - TreeSet과 유사하나 Key-Value 구조
  - 자동 키 정렬
  - 삽입/탐색/삭제 O(log n)
  - `subMap`, `floorKey`, `ceilingKey` 등 API 제공

### ✅ 사용 기준 요약

- **존재 여부만 빠르게 확인** → `HashSet`
- **키-값 매핑이 필요** → `HashMap`
- **입력 순서를 유지해야 함** → `LinkedHashSet`, `LinkedHashMap`
- **자동 정렬 및 범위 기반 탐색 필요** → `TreeSet`, `TreeMap`

---

## 4. 문자열 탐색

- KMP (Knuth–Morris–Pratt)
- Rabin-Karp
- Z-Algorithm
- Trie (접두사 트리 탐색)
- Suffix Array + LCP 배열
- Manacher’s Algorithm

---

## 5. 그래프 탐색
### 경로를 탐색하거나 거리/도달 여부를 구하는 알고리즘

| 알고리즘                                                                       | 시간 복잡도              | 추천 상황                                                     | 사용 가능 범위                     |
|----------------------------------------------------------------------------|--------------------------|----------------------------------------------------------------|------------------------------|
| [DFS](detail/DFSBFS.md)                                                    | O(V + E)                 | 모든 경로 / 경우의 수 탐색, 재귀 구조, 백트래킹 문제           | V ≤ 100,000<br>(재귀 깊이 주의)    |
| [BFS](detail/DFSBFS.md)                                                    | O(V + E)                 | 동일 가중치일 때 최단 거리 (예: 미로, 최소 횟수)              | V ≤ 100,000                  |
| [다익스트라](detail/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC.md)           | O(E log V)               | 양의 가중치 그래프에서 최단 거리 계산                         | V ≤ 100,000<br>E ≤ 1,000,000 |
| [0-1 BFS](detail/DFSBFS.md)                                                | O(V + E)                 | 가중치가 0 또는 1인 그래프에서 최단 거리                       | V ≤ 100,000                  |
| [A\*](detail/AStar.md)                                                     | O(E) (휴리스틱에 따라 다름) | 휴리스틱 기반 경로 탐색, 게임/실시간 탐색                     | V 중간, 실시간 경로 탐색용             |
| [플로이드워셜](detail/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%9B%8C%EC%85%9C.md) | O(V³)                    | 모든 정점 간 최단 거리 계산 필요할 때 (작은 그래프에 한함)     | V ≤ 500                      |
| [벨만포드.md](detail/%EB%B2%A8%EB%A7%8C%ED%8F%AC%EB%93%9C.md)                  | O(VE)                    | 음수 간선 존재 가능, 음수 사이클 탐지 필요할 때               | V ≤ 5,000<br>E ≤ 100,000     |

> 💡 실전에서는 다익스트라와 BFS가 가장 자주 쓰이며, 정점 수가 작을 경우에만 플로이드-워셜이 쓰입니다.

### 래프 연결 구조 중 최소 비용을 찾기

- **🔗 최소 신장 트리 (MST)**
| 알고리즘         | 시간복잡도                  | 추천 상황 |
|------------------|------------------------------|------------|
| **[프림(Prim)](detail/MST.md)**   | O(E log V) (PQ + 인접리스트) | **Dense 그래프**, 시작점부터 확장할 때 |
| **[크루스칼(Kruskal)](detail/MST.md)** | O(E log E)                | **Sparse 그래프**, 간선이 적고 정점이 많을 때 |

---

## 6. 트리/구간 구조 탐색

- 이진 탐색 트리 (BST)
- 힙 / 우선순위 큐
- [세그먼트 트리 (Segment Tree)](detail/%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%ED%8A%B8%EB%A6%AC.md)
- 펜윅 트리 (Fenwick Tree / BIT)

---

## 🧠 참고 요약

| 카테고리 | 특징 |
|----------|------|
| **선형 탐색** | 순차적, 구현 쉬움, 느림 |
| **이진 탐색 계열** | 정렬 필수, 빠름 (O(log n)) |
| **해시 탐색** | 평균 O(1), 충돌 시 O(n) |
| **문자열 탐색** | 효율적 서브스트링 탐색 |
| **그래프 탐색** | 최단경로, 경로 유무, 탐색 순서 |
| **트리/구간 탐색** | 구간합/최대/최소 등 빠르게 처리 |

---
