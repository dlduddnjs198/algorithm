알겠습니다. 요청하신 포맷 그대로, 세그먼트 트리 형식에 맞춰 **벨만-포드 알고리즘**을 `Markdown` 형식으로 정리해드리겠습니다:

---

## 정의

\*\*벨만-포드 알고리즘(Bellman-Ford Algorithm)\*\*은 **음의 가중치 간선이 있는 그래프**에서도
**단일 시작점으로부터 모든 정점까지의 최단 경로**를 구할 수 있는 최단 경로 알고리즘이다.
**음의 사이클 여부도 탐지할 수 있는** 점이 큰 특징이다.

---

## 🧠 간단한 비유

* 정점과 간선이 있는 그래프가 있다.
* 다익스트라는 음수 간선에서 오류가 발생할 수 있지만, 벨만-포드는 이를 처리할 수 있다.
* 매 반복마다 모든 간선을 순회하면서, 현재까지 알려진 거리보다 더 짧은 거리가 있다면 갱신(완화)한다.

```
정점: A, B, C  
간선: A → B (4), B → C (-2), A → C (5)

1단계: A → B = 4, A → C = 5  
2단계: B → C = 4 + (-2) = 2 → C 값 갱신됨  
```

---

## 언제 쓰는가?

1. 음의 가중치 간선이 있는 그래프에서 최단 경로를 구할 때
2. 음의 사이클 존재 여부를 판단해야 할 때
3. 그래프의 정점 수가 작고, 간선 수가 적당할 때
4. 단일 시작점에서 모든 정점으로 가는 경로를 구해야 할 때

---

## 📈 시간복잡도

| 연산        | 시간복잡도    |
| --------- | -------- |
| 최단경로 계산   | O(V × E) |
| 음의 사이클 판별 | O(E)     |

---

## 만드는법

1. 초기화(init)
2. V-1번 간선 반복 탐색(relaxation)
3. V번째 반복으로 음의 사이클 유무 확인

---

## 코드 예시

1. [밸만포드 기본형](../code/BellmanFord.java)
2. [SPFA 최적화형](../code/BellmanFord_SPFA.java) → 큐를 사용하여 평균 속도 개선

---

## 관련 문제

### 백준

1. [타임머신 (BOJ 11657)](https://www.acmicpc.net/problem/11657)
2. [웜홀 (BOJ 1865)](https://www.acmicpc.net/problem/1865)

---

## ⚙️ 실전 활용 예시

| 문제 유형        | 적용               |
| ------------ | ---------------- |
| 음의 가중치 최단 경로 | ✅                |
| 음의 사이클 탐지    | ✅                |
| 양수 간선만 있는 경우 | ❌ (다익스트라가 더 효율적) |
| 전체 정점 쌍 경로   | ❌ (플로이드-워셜 권장)   |

---

## 🧠 자주 쓰이는 변형

1. SPFA (Shortest Path Faster Algorithm)
2. Johnson’s Algorithm (모든 쌍 최단경로에 응용)
3. DP 기반 K단계 제한 최단경로

| 이름                      | 설명                        |
| ----------------------- | ------------------------- |
| **SPFA**                | 큐를 사용한 벨만포드 최적화           |
| **Johnson’s Algorithm** | 벨만포드 + 다익스트라 조합으로 모든 쌍 경로 |
| **K단계 제한 경로**           | 단계 수 제한된 벨만포드 응용          |

---

## ✅ 벨만포드 알고리즘 응용/변형 총정리

| 이름                      | 핵심 기능                   | 시간복잡도 (쿼리/업데이트)    | 특징              | 사용 상황 (세분화)                                   | 차원 |
| ----------------------- | ----------------------- | ------------------ | --------------- | --------------------------------------------- | -- |
| **기본 Bellman-Ford**     | 음수 가중치 최단 경로, 음의 사이클 탐지 | `O(VE)`            | 간단한 구현, 직관적     | ▸ **음수 간선 포함 경로 탐색**<br>▸ **음의 사이클 존재 여부 판단** | 1D |
| **SPFA**                | 큐 기반 최적화                | `평균 O(E)`          | 실제로는 빠름, 최악은 동일 | ▸ **벨만포드 최적화**<br>▸ 실전 대회용                    | 1D |
| **DP 제한형**              | 단계 제한 경로                | `O(KE)`            | K단계 이내 경로 탐색    | ▸ **K단계 이하 경로**<br>▸ 항공권 가격 누적 등              | 1D |
| **Johnson’s Algorithm** | 모든 쌍 경로 + 음수 허용         | `O(VE + V² log V)` | 다익스트라+벨만포드 결합   | ▸ **모든 쌍 최단 경로 문제**<br>▸ **음수 간선 포함**         | 2D |

---

### 📌 참고 사항

* 다익스트라는 음수 간선이 있을 경우 잘못된 결과를 줄 수 있으므로 사용 불가
* 벨만-포드는 느리지만 가장 일반적인 경우에 대응 가능
* 음의 사이클 여부를 확인하고 싶을 때는 유일한 방법 중 하나

---

## 💡 정리 팁

| 상황              | 추천 알고리즘             |
| --------------- | ------------------- |
| 음수 간선이 있음       | 벨만포드                |
| 음의 사이클 탐지 필요    | 벨만포드                |
| 양수 간선, 빠른 계산 필요 | 다익스트라               |
| 모든 쌍 경로         | 플로이드-워셜 / Johnson’s |

---
