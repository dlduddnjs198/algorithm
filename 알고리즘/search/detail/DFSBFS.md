## ✅ 2차원 배열 탐색: DFS vs BFS 선택 기준

### 공통 시간복잡도
- **O(N × M)** — 모든 칸을 한 번씩 방문한다고 가정

### 공통 공간복잡도
- **DFS (재귀)**: **최대 O(N + M)** (재귀 콜 스택 크기)
- **DFS (스택 직접 구현)**: O(N × M)
- **BFS (큐)**: **최악 O(N × M)** (큐에 모든 칸이 들어갈 수 있음)

---

## 🔍 사용 기준 정리

| 크기 (`N × M`) | DFS (재귀) | DFS (스택) | BFS (큐) | 비고 |
|----------------|------------|------------|----------|------|
| `<= 500 × 500` | ✅ 사용 가능 (재귀 깊이 주의) | ✅ | ✅ | 대부분 무난 |
| `> 1000 × 1000` | ⚠️ 스택 오버플로우 위험 | ✅ | ✅ (메모리 주의) | 재귀 DFS는 ❌ |
| `> 2000 × 2000` | ❌ | ✅ (공간 넉넉할 때) | ⚠️ 큐 메모리 부족 가능 | 상황 따라 선택 |

---

## 📌 핵심 요약

- **작은 그래프 (≤ 500×500)**  
  → DFS 재귀 OK (단, 자바는 `재귀 깊이 제한` 신경 써야 함)

- **중형 그래프 (≤ 1000×1000)**  
  → DFS 재귀는 위험할 수 있음 → **BFS or 스택 DFS 권장**

- **큰 그래프 (> 2000×2000)**  
  → DFS 재귀 ❌, **스택 DFS or BFS with queue** 사용  
  → 메모리 제한(128MB/256MB) 있는 문제라면 **큐 사이즈 주의**

---

## ✅ 선택 팁 요약

| 조건 | 추천 알고리즘 | 이유 |
|------|----------------|------|
| 도달 여부만 확인 | DFS | 빠르게 탈출 가능 (재귀 DFS 또는 스택 DFS) |
| 최단 거리 | BFS | 가중치 없는 최단 거리 보장 |
| 넓은 영역 탐색 (구역 수 세기 등) | DFS/BFS 둘 다 가능 | 구현 편한 쪽 선택 |
| 큰 격자 + 시간 제한 여유 없음 | BFS (속도 안정적) | DFS 재귀보다 안정적 |
| 큰 격자 + 메모리 제한 엄격 | DFS (스택 직접 구현) | BFS 큐보다 메모리 덜 씀 |

---

# DFS & BFS 선택기준

## ✅ 1. **도달 조건이 있다면 → BFS가 더 빠르다**
- BFS는 **최단 거리 보장 + 빠른 탈출 가능**
- 예시: 목표 지점 도달만 하면 되는 미로 문제 등

```text
[DFS는 깊이 우선] → 멀리 갔다가 돌아와야 해서 시간 손해  
[BFS는 넓이 우선] → 가장 가까운 정점 먼저 탐색해서 빠르게 도달
```

---

## ✅ 2. **전체 영역 탐색 or 카운트 목적 → DFS가 더 빠르다**
- 예시: 섬 개수 세기, 영역 나누기, 그룹 번호 붙이기 등

```text
[DFS는 스택 구조라 연산이 더 단순] → 큐를 사용하는 BFS보다 overhead 작음  
→ 특히 재귀 DFS는 빠르게 전체 탐색 가능 (단, 재귀 깊이 주의)
```

---

## ✅ 3. 시간 비교 요약 (대부분의 경우)

| 상황 | DFS | BFS |
|------|-----|-----|
| 도달 여부 | ❌ 느릴 수 있음 | ✅ 빠름 |
| 최단 거리 | ❌ 불가 | ✅ 가능 |
| 전체 영역 탐색 | ✅ 빠름 | ✅ 느릴 수 있음 |
| 구현 난이도 | ✅ 간단 (재귀 가능) | ✅ 직관적 (큐로 구현) |

---

## ✅ 결론 정리

| 조건 | 추천 | 이유 |
|------|------|------|
| **목표 지점 도달 or 최단 거리** | **BFS** | 최단 거리 보장, 빠른 탈출 |
| **전체 탐색, 개수 세기** | **DFS** | 호출/연산 적고 빠름 |
| **매우 큰 맵 (재귀 깊이 문제)** | BFS or 스택 DFS | 재귀 DFS는 위험 |

** 큐에 10만개 이상 쌓일 것 같으면 안된다.

## 🧩 0-1 BFS (0-1 가중치 그래프의 최단 경로)

### ✅ 언제 사용하는가?

* 간선의 가중치가 **0 또는 1**인 경우
  예: 벽은 1, 통로는 0 등으로 표현되는 문제
* 일반 BFS는 가중치를 표현하지 못하고, 다익스트라는 느릴 수 있음
  → **0-1 BFS가 가장 효율적**

---

### ✅ 동작 원리

* **`Deque` (양방향 큐)** 사용
* 가중치가:

  * **0** → 앞에 넣기 (`addFirst`)
  * **1** → 뒤에 넣기 (`addLast`)

```java
// 현재 위치를 나타내는 Node 클래스 (x좌표, y좌표)
class Node {
  int x, y;
  Node(int x, int y) { this.x = x; this.y = y; }
}

// 맵 정보
int[][] map = ...; // map[x][y] = 0 (빈칸), 1 (벽)
int[][] dist = new int[N][M]; // dist[x][y] = (0,0)부터 (x,y)까지 최소 비용 (벽을 부순 횟수)

// 초기화: dist 배열은 무한대로 설정 (아직 방문하지 않은 상태)
for (int[] row : dist) Arrays.fill(row, Integer.MAX_VALUE);

// 덱: 0-1 BFS는 일반 큐가 아닌 덱을 사용
Deque<Node> dq = new ArrayDeque<>();

// 시작 위치 추가 (0,0)부터 시작, 초기 비용은 0
dq.addFirst(new Node(0, 0));
dist[0][0] = 0;

// 방향 배열: 상,하,좌,우
int[] dx = {-1, 1, 0, 0};
int[] dy = {0, 0, -1, 1};

// 덱이 빌 때까지 반복
while (!dq.isEmpty()) {
Node cur = dq.pollFirst(); // 덱 앞에서 꺼냄 → 가장 우선 순위 높은 위치

// 4방향 탐색
    for (int d = 0; d < 4; d++) {
int nx = cur.x + dx[d];
int ny = cur.y + dy[d];

// 유효한 좌표인지 확인
        if (inRange(nx, ny)) {
int cost = map[nx][ny]; // 0이면 빈칸, 1이면 벽 (부수는 데 1 비용)

// 현재 위치에서 cost를 더해서 가는 게 더 최적이면 갱신
            if (dist[nx][ny] > dist[cur.x][cur.y] + cost) {
dist[nx][ny] = dist[cur.x][cur.y] + cost;

// 가중치가 0이면 덱 앞에 넣기 (우선 탐색)
                if (cost == 0) dq.addFirst(new Node(nx, ny));
        // 가중치가 1이면 덱 뒤에 넣기 (나중에 탐색)
        else dq.addLast(new Node(nx, ny));
        }
        }
        }
        }
```

---

### ✅ 시간복잡도

* **O(V + E)**
  → 다익스트라(O(E log V))보다 빠르고, 일반 BFS처럼 큐를 사용하므로 구현도 간단

---

### ✅ 예시 상황

| 문제 유형    | 설명                        |
| -------- | ------------------------- |
| 벽 부수고 이동 | 벽(1), 길(0)로 구성된 맵         |
| 토글 상태 전환 | 상태를 바꿀 때 비용이 0/1로 주어지는 문제 |
| 최소 조작 횟수 | 조작할 때마다 0/1의 비용 발생        |

---

### ✅ 요약

| 조건          | 추천 알고리즘       |
| ----------- | ------------- |
| 가중치 없음      | BFS           |
| 가중치 0/1만 존재 | **0-1 BFS** ⬅ |
| 일반 양의 가중치   | 다익스트라         |
| 음수 가중치 포함   | 벨만-포드         |
