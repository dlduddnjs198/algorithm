# 📌 비트마스킹(Bitmasking) 완전 정복

---

## ✅ 비트마스킹이란?

* 정수의 **이진 표현(2진수)을 이용**하여, **여러 boolean 상태를 하나의 정수로 압축**하여 관리하는 기법입니다.
* 주로 다음 상황에서 사용됩니다:

    * 부분집합 탐색 (총 N개의 원소 중 어떤 것들을 선택했는지)
    * 방문 여부 체크 (`boolean[] visited` 대신)
    * 상태 저장이 필요한 DP (ex. 외판원 순회 문제)

---

## ✅ 비트 연산 기본

| 연산자  | 이름 | 설명                    | 예시                     |
|------|--| --------------------- |------------------------|
| `<<` | 왼쪽 시프트 | `1 << i` → 2^i        | `1 << 2 = 4` (`100`)   |
| `>>` | 오른쪽 시프트 | `x >> i` → x를 2^i로 나눈 몫 | `8 >> 1 = 4`           |
| `&`  | AND | 둘 다 1일 때만 1           | `1010 & 1100 = 1000`   |
| `\|` | OR  | 하나라도 1이면 1            | `1010 \| 1100 = 1110`  |
| `^`  | XOR | 다르면 1                 | `1010 ^ 1100 = 0110`   |
| `~`  | NOT | 비트 반전                 | `~1010 = ...0101` (보수) |

---

## ✅ 기본 사용법

| 목적          | 코드                       | 설명                     |
| ----------- |--------------------------| ---------------------- |
| `i`번째 비트 켜기 | `mask \|= (1 << i);`     | `i`번째 비트를 1로 만듦 |
| `i`번째 비트 끄기 | `mask &= ~(1 << i);`     | `i`번째 비트를 0으로 만듦       |
| `i`번째 비트 토글 | `mask ^= (1 << i);`      | `i`번째 비트를 반전함          |
| `i`번째 비트 확인 | `(mask & (1 << i)) != 0` | `i`번째 비트가 켜져 있는지 확인    |
| 비트 개수 세기    | `Integer.bitCount(mask)` | 켜진 비트의 개수(부분집합 원소 수 등) |

---

## ✅ 예제 문제 유형

### ✔️ 1. 부분집합 생성 (Subset Generation)

* 모든 부분집합을 비트마스크로 표현
* 총 N개의 원소라면 가능한 조합 수는 `2^N`
* 예: `for (int mask = 0; mask < (1 << N); mask++)`

### ✔️ 2. 방문 여부 관리 (Visited Array 대체)

* `visited[5] = true` → `mask |= (1 << 5);`
* `if ((mask & (1 << 5)) != 0)` → 5번 정점 방문 여부 확인

### ✔️ 3. DP + 비트마스크 (외판원 순회 등)

* 상태를 `dp[현재위치][방문한곳의 마스크]`로 표현
* 방문 상태를 비트로 압축해서 저장하면 공간 효율↑

---

## ✅ 장점

* 메모리 사용량 절감 (`boolean[N]` 대신 `int` 또는 `long`)
* 빠른 연산: 모든 연산이 O(1)
* 코드 간결화 및 부분집합 구현 단순화

---

## ✅ 주의점

* **비트마스크는 최대 32비트 (int), 64비트 (long)까지만 표현 가능**

    * `N > 20` 이상이면 비트마스크를 쓰는 것이 부담되거나 불가능함
    * 그 이상은 `Set<Integer>`, `BigInteger`, 또는 Trie 등으로 대체

---

## ✅ 실전 문제 예시 링크

* [부분집합 생성 문제](#) 🔗
* [외판원 순회 문제 (TSP + DP + Bitmask)](#) 🔗
* [최소 점프 횟수 with 상태 저장](#) 🔗

---

## ✅ 정리

| 목적       | 비트마스크 장점                      |
| -------- | ----------------------------- |
| 부분집합 구하기 | `mask`로 원소 포함 여부 간단 확인        |
| 방문 여부 체크 | `boolean[]` 대신 `int`로 O(1) 관리 |
| DP 상태 표현 | `dp[위치][mask]` → 공간 효율적       |

> ⚠️ **비트 연산은 익숙해지기까지 시간이 걸리므로, 자주 쓰는 패턴을 기억하고 예제를 반복 연습하는 것이 중요합니다!**
