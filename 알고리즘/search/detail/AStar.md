# ğŸ“˜ A\* (A-Star) ì•Œê³ ë¦¬ì¦˜

---

## âœ… ì •ì˜

* **ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜**ìœ¼ë¡œ, `Dijkstra` + `Heuristic(íœ´ë¦¬ìŠ¤í‹±)` ê¸°ë°˜ì˜ ì•Œê³ ë¦¬ì¦˜
* ì‹œì‘ ì§€ì ì—ì„œ ëª©í‘œ ì§€ì ê¹Œì§€ **ê°€ì¥ ìœ ë§í•œ ê²½ë¡œë¥¼ ìš°ì„  íƒìƒ‰**í•¨ìœ¼ë¡œì¨ ì„±ëŠ¥ì„ ê·¹ëŒ€í™”
* **Greedy + Dynamic Programming** í˜¼í•© êµ¬ì¡°
* ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ê±°ì˜ ì•ˆì“°ì„

---

## âœ… ì „ì œ ì¡°ê±´

| ì¡°ê±´                            | ì„¤ëª…                      |
| ----------------------------- | ----------------------- |
| âœ… ì–‘ì˜ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„                  | `g(n)`ì€ í•­ìƒ 0 ì´ìƒì˜ ê±°ë¦¬     |
| âœ… ëª©í‘œ ì§€ì ì´ ëª…í™•íˆ ì •í•´ì§              | ëª©ì ì§€ê°€ ìˆì„ ë•Œ ì‚¬ìš©            |
| âœ… íœ´ë¦¬ìŠ¤í‹±ì´ admissible (ë‚™ê´€ì ì´ì–´ì•¼ í•¨) | ì¦‰, ì‹¤ì œ ë¹„ìš©ì„ ê³¼ëŒ€ í‰ê°€í•˜ì§€ ì•Šì•„ì•¼ í•¨ |

---

## âœ… í•µì‹¬ ì•„ì´ë””ì–´

> `f(n) = g(n) + h(n)`
> ì´ ì˜ˆìƒ ë¹„ìš© = í˜„ì¬ê¹Œì§€ ì˜¨ ê±°ë¦¬ + ì•ìœ¼ë¡œì˜ ì˜ˆìƒ ê±°ë¦¬

* `g(n)`: ì‹œì‘ì  â†’ í˜„ì¬ ë…¸ë“œê¹Œì§€ì˜ **ì‹¤ì œ ë¹„ìš©**
* `h(n)`: í˜„ì¬ ë…¸ë“œ â†’ ëª©í‘œ ë…¸ë“œê¹Œì§€ì˜ **ì˜ˆìƒ ë¹„ìš© (íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜)**
* `f(n)`: **ì´ ë…¸ë“œë¥¼ ì„ íƒí•  ìš°ì„ ìˆœìœ„**

â†’ `f(n)`ì´ ê°€ì¥ ì‘ì€ ë…¸ë“œë¥¼ ë¨¼ì € íƒìƒ‰
â†’ ëª©í‘œ ì§€ì ì— ë¹ ë¥´ê²Œ ë„ë‹¬í•  ê°€ëŠ¥ì„±ì´ ë†’ì€ ê²½ë¡œë¶€í„° íƒìƒ‰

---

## âœ… A\* ì•Œê³ ë¦¬ì¦˜ ë™ì‘ íë¦„

1. **ì‹œì‘ ë…¸ë“œë¥¼ open ë¦¬ìŠ¤íŠ¸ì— ë„£ìŒ**
2. open ë¦¬ìŠ¤íŠ¸ì—ì„œ `f(n)`ì´ ê°€ì¥ ì‘ì€ ë…¸ë“œë¥¼ êº¼ëƒ„ â†’ í˜„ì¬ ë…¸ë“œ(`current`)
3. `current == ëª©í‘œ ë…¸ë“œ`ë©´ ì¢…ë£Œ
4. `current`ì˜ ì¸ì ‘ ë…¸ë“œë“¤ ê°ê°ì— ëŒ€í•´:

    * `g(n)` ê°±ì‹  ì‹œë„: í˜„ì¬ê¹Œì§€ ê±°ë¦¬ + ì´ë™ ë¹„ìš©
    * `h(n)` ê³„ì‚° (ë³´í†µ íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ë¡œ ë¯¸ë¦¬ ì •ì˜ë¨)
    * `f(n) = g(n) + h(n)` ì—…ë°ì´íŠ¸
    * ë” ì§§ì€ ê²½ë¡œë©´ open ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
5. ìœ„ ê³¼ì •ì„ open ë¦¬ìŠ¤íŠ¸ê°€ ë¹Œ ë•Œê¹Œì§€ ë°˜ë³µ

---

## âœ… ì‹œê°„ ë³µì¡ë„

| êµ¬ì„± ìš”ì†Œ              | ë³µì¡ë„                               |
| ------------------ | --------------------------------- |
| ìµœì•…ì˜ ê²½ìš°             | **O(E)** or **O(VÂ²)** (í™ ì—†ì´ êµ¬í˜„ ì‹œ) |
| ìš°ì„ ìˆœìœ„ í + ì¸ì ‘ ë¦¬ìŠ¤íŠ¸    | **O(E log V)** (ë³´í†µ ì´ ë°©ì‹ ì‚¬ìš©)       |
| `h(n)`ì´ ë„ˆë¬´ ë‚™ê´€ì ì¼ ê²½ìš° | ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥ì„± ìˆìŒ                      |

---

## âœ… ì‚¬ìš© ì˜ˆì‹œ

| ìƒí™©                     | ì„¤ëª…                  |
| ---------------------- | ------------------- |
| âœ… ê²½ë¡œ íƒìƒ‰                | GPS, ë„¤ë¹„ê²Œì´ì…˜, ê²Œì„ AI ë“± |
| âœ… ë¹ ë¥¸ ê²½ë¡œ + íš¨ìœ¨ì„± í•„ìš”í•  ë•Œ    | Dijkstraë³´ë‹¤ ì¼ë°˜ì ìœ¼ë¡œ ë¹ ë¦„ |
| âŒ h(n) ì¶”ì •ì´ ì–´ë µê±°ë‚˜ ë¶€ì •í™•í•  ë•Œ | ì„±ëŠ¥ ë˜ëŠ” ì •í™•ë„ ì €í•˜ ê°€ëŠ¥     |

---

## âœ… A\* ì•Œê³ ë¦¬ì¦˜ vs ë‹¤ìµìŠ¤íŠ¸ë¼

| í•­ëª©                  | ë‹¤ìµìŠ¤íŠ¸ë¼          | A\*                 |
| ------------------- | -------------- | ------------------- |
| **ìš°ì„ ìˆœìœ„ ê¸°ì¤€**         | í˜„ì¬ê¹Œì§€ì˜ ì‹¤ì œ ê±°ë¦¬(g) | ì‹¤ì œ ê±°ë¦¬(g) + ì¶”ì • ê±°ë¦¬(h) |
| **ëª©í‘œì— ëŒ€í•œ ì •ë³´ ì‚¬ìš© ì—¬ë¶€** | âŒ ì‚¬ìš© ì•ˆ í•¨       | âœ… ì‚¬ìš©í•¨ (heuristic)   |
| **ì‚¬ìš© ëª©ì **           | ì „ì²´ ìµœë‹¨ ê±°ë¦¬       | **íŠ¹ì • ëª©ì ì§€ë¡œ ìµœì  ê²½ë¡œ**   |
| **ì†ë„/íš¨ìœ¨**           | ëª¨ë“  ê²½ë¡œ íƒìƒ‰       | **í•„ìš”í•œ ê²½ë¡œë§Œ íƒìƒ‰** (ë¹ ë¦„) |

---

## âœ… íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ ì˜ˆì‹œ (`h(n)`)

| ìƒí™©             | íœ´ë¦¬ìŠ¤í‹± (ì˜ˆìƒ ë¹„ìš© í•¨ìˆ˜)                            |         |   |         |    |
| -------------- | ------------------------------------------ | ------- | - | ------- | -- |
| 2D ê²©ì (4ë°©í–¥ ì´ë™) | ë§¨í•´íŠ¼ ê±°ë¦¬: \`                                 | x1 - x2 | + | y1 - y2 | \` |
| 2D ê²©ì (ëŒ€ê°ì„  í¬í•¨) | ìœ í´ë¦¬ë“œ ê±°ë¦¬: `sqrt((x1 - x2)^2 + (y1 - y2)^2)` |         |   |         |    |
| ì¼ë°˜ ê·¸ë˜í”„         | ë„ë©”ì¸ ì§€ì‹ ê¸°ë°˜ ê±°ë¦¬ ì¶”ì • í•¨ìˆ˜                         |         |   |         |    |

> ë°˜ë“œì‹œ **ë‚™ê´€ì ì´ì–´ì•¼ í•¨ (admissible)**
> â†’ ì‹¤ì œ ê±°ë¦¬ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì•„ì•¼ í•¨

---

## âœ… ì˜ˆì‹œ ê·¸ë˜í”„

```
S = ì‹œì‘, G = ëª©í‘œ, X = ë²½ ë˜ëŠ” ì¥ì• ë¬¼

S . . .
. X . .
. X G .

â†’ A*ëŠ” ëª©ì ì§€ Gë¥¼ í–¥í•´ íœ´ë¦¬ìŠ¤í‹± ê¸°ë°˜ìœ¼ë¡œ ë˜‘ë˜‘í•˜ê²Œ íƒìƒ‰
â†’ ë‹¤ìµìŠ¤íŠ¸ë¼ëŠ” ëª¨ë“  ë°©í–¥ìœ¼ë¡œ í¼ì§
```

---

## âœ… ì£¼ì˜ ì‚¬í•­

* **`h(n)`ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ â†’ ë‹¤ìµìŠ¤íŠ¸ë¼ì²˜ëŸ¼ ëŠë ¤ì§**
* **`h(n)`ì´ ë„ˆë¬´ í¬ë©´ â†’ ìµœë‹¨ ê²½ë¡œ ë³´ì¥ ì•ˆë¨**
* ë°˜ë“œì‹œ **h(n)ëŠ” admissibleí•˜ê³  consistentí•´ì•¼ í•¨**
* ê°„ì„  ë¹„ìš©ì€ **ìŒìˆ˜ ë¶ˆê°€**

---

## âœ… Java ì½”ë“œ ìŠ¤ë‹ˆí«

```java
class Node implements Comparable<Node> {
    int x, y, g, h;
    Node parent;

    Node(int x, int y, int g, int h, Node parent) {
        this.x = x;
        this.y = y;
        this.g = g;
        this.h = h;
        this.parent = parent;
    }

    int f() {
        return g + h;
    }

    @Override
    public int compareTo(Node o) {
        return Integer.compare(this.f(), o.f());
    }
}
```

---

## âœ… ì „ì²´ ê²½ë¡œ ì¶”ì  ë°©ì‹

* ê° ë…¸ë“œì— `parent` í¬ì¸í„°ë¥¼ ìœ ì§€
* ëª©í‘œ ë…¸ë“œì—ì„œ ì—­ì¶”ì í•˜ë©´ì„œ ê²½ë¡œ ë³µì›

```java
List<Node> reconstructPath(Node goal) {
    List<Node> path = new ArrayList<>();
    for (Node node = goal; node != null; node = node.parent) {
        path.add(node);
    }
    Collections.reverse(path);
    return path;
}
```

---

## âœ… ë§ˆë¬´ë¦¬ ìš”ì•½

* `f(n) = g(n) + h(n)`ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ ê²°ì •
* ëª©ì ì§€ë¥¼ í–¥í•œ íœ´ë¦¬ìŠ¤í‹± ê¸°ë°˜ íƒìƒ‰
* ì •í™•ì„±ê³¼ ì„±ëŠ¥ì„ ë™ì‹œì— ì¡ì„ ìˆ˜ ìˆëŠ” **ìµœê°•ì˜ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜**

## ì˜ˆì‹œ ë¬¸ì œ
