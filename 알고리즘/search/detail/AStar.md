# 📘 A\* (A-Star) 알고리즘

---

## ✅ 정의

* **최단 경로 탐색 알고리즘**으로, `Dijkstra` + `Heuristic(휴리스틱)` 기반의 알고리즘
* 시작 지점에서 목표 지점까지 **가장 유망한 경로를 우선 탐색**함으로써 성능을 극대화
* **Greedy + Dynamic Programming** 혼합 구조
* 코딩테스트에서는 거의 안쓰임

---

## ✅ 전제 조건

| 조건                            | 설명                      |
| ----------------------------- | ----------------------- |
| ✅ 양의 가중치 그래프                  | `g(n)`은 항상 0 이상의 거리     |
| ✅ 목표 지점이 명확히 정해짐              | 목적지가 있을 때 사용            |
| ✅ 휴리스틱이 admissible (낙관적이어야 함) | 즉, 실제 비용을 과대 평가하지 않아야 함 |

---

## ✅ 핵심 아이디어

> `f(n) = g(n) + h(n)`
> 총 예상 비용 = 현재까지 온 거리 + 앞으로의 예상 거리

* `g(n)`: 시작점 → 현재 노드까지의 **실제 비용**
* `h(n)`: 현재 노드 → 목표 노드까지의 **예상 비용 (휴리스틱 함수)**
* `f(n)`: **이 노드를 선택할 우선순위**

→ `f(n)`이 가장 작은 노드를 먼저 탐색
→ 목표 지점에 빠르게 도달할 가능성이 높은 경로부터 탐색

---

## ✅ A\* 알고리즘 동작 흐름

1. **시작 노드를 open 리스트에 넣음**
2. open 리스트에서 `f(n)`이 가장 작은 노드를 꺼냄 → 현재 노드(`current`)
3. `current == 목표 노드`면 종료
4. `current`의 인접 노드들 각각에 대해:

    * `g(n)` 갱신 시도: 현재까지 거리 + 이동 비용
    * `h(n)` 계산 (보통 휴리스틱 함수로 미리 정의됨)
    * `f(n) = g(n) + h(n)` 업데이트
    * 더 짧은 경로면 open 리스트에 추가
5. 위 과정을 open 리스트가 빌 때까지 반복

---

## ✅ 시간 복잡도

| 구성 요소              | 복잡도                               |
| ------------------ | --------------------------------- |
| 최악의 경우             | **O(E)** or **O(V²)** (힙 없이 구현 시) |
| 우선순위 큐 + 인접 리스트    | **O(E log V)** (보통 이 방식 사용)       |
| `h(n)`이 너무 낙관적일 경우 | 성능 저하 가능성 있음                      |

---

## ✅ 사용 예시

| 상황                     | 설명                  |
| ---------------------- | ------------------- |
| ✅ 경로 탐색                | GPS, 네비게이션, 게임 AI 등 |
| ✅ 빠른 경로 + 효율성 필요할 때    | Dijkstra보다 일반적으로 빠름 |
| ❌ h(n) 추정이 어렵거나 부정확할 때 | 성능 또는 정확도 저하 가능     |

---

## ✅ A\* 알고리즘 vs 다익스트라

| 항목                  | 다익스트라          | A\*                 |
| ------------------- | -------------- | ------------------- |
| **우선순위 기준**         | 현재까지의 실제 거리(g) | 실제 거리(g) + 추정 거리(h) |
| **목표에 대한 정보 사용 여부** | ❌ 사용 안 함       | ✅ 사용함 (heuristic)   |
| **사용 목적**           | 전체 최단 거리       | **특정 목적지로 최적 경로**   |
| **속도/효율**           | 모든 경로 탐색       | **필요한 경로만 탐색** (빠름) |

---

## ✅ 휴리스틱 함수 예시 (`h(n)`)

| 상황             | 휴리스틱 (예상 비용 함수)                            |         |   |         |    |
| -------------- | ------------------------------------------ | ------- | - | ------- | -- |
| 2D 격자 (4방향 이동) | 맨해튼 거리: \`                                 | x1 - x2 | + | y1 - y2 | \` |
| 2D 격자 (대각선 포함) | 유클리드 거리: `sqrt((x1 - x2)^2 + (y1 - y2)^2)` |         |   |         |    |
| 일반 그래프         | 도메인 지식 기반 거리 추정 함수                         |         |   |         |    |

> 반드시 **낙관적이어야 함 (admissible)**
> → 실제 거리보다 작거나 같아야 함

---

## ✅ 예시 그래프

```
S = 시작, G = 목표, X = 벽 또는 장애물

S . . .
. X . .
. X G .

→ A*는 목적지 G를 향해 휴리스틱 기반으로 똑똑하게 탐색
→ 다익스트라는 모든 방향으로 퍼짐
```

---

## ✅ 주의 사항

* **`h(n)`이 너무 작으면 → 다익스트라처럼 느려짐**
* **`h(n)`이 너무 크면 → 최단 경로 보장 안됨**
* 반드시 **h(n)는 admissible하고 consistent해야 함**
* 간선 비용은 **음수 불가**

---

## ✅ Java 코드 스니펫

```java
class Node implements Comparable<Node> {
    int x, y, g, h;
    Node parent;

    Node(int x, int y, int g, int h, Node parent) {
        this.x = x;
        this.y = y;
        this.g = g;
        this.h = h;
        this.parent = parent;
    }

    int f() {
        return g + h;
    }

    @Override
    public int compareTo(Node o) {
        return Integer.compare(this.f(), o.f());
    }
}
```

---

## ✅ 전체 경로 추적 방식

* 각 노드에 `parent` 포인터를 유지
* 목표 노드에서 역추적하면서 경로 복원

```java
List<Node> reconstructPath(Node goal) {
    List<Node> path = new ArrayList<>();
    for (Node node = goal; node != null; node = node.parent) {
        path.add(node);
    }
    Collections.reverse(path);
    return path;
}
```

---

## ✅ 마무리 요약

* `f(n) = g(n) + h(n)`으로 우선순위 결정
* 목적지를 향한 휴리스틱 기반 탐색
* 정확성과 성능을 동시에 잡을 수 있는 **최강의 최단 경로 알고리즘 중 하나**

## 예시 문제
